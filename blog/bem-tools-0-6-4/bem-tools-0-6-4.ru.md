#Версия bem-tools 0.6.4

Привет!

Стабильная версия [bem-tools](https://ru.bem.info/tools/bem/bem-tools/) 0.6.4 доступна.

В этой версии:
  * Добавлено новое API технологий;
  * Увеличена скорость сборки bem make / server при использовании нового API.

**ВАЖНО: для установки необходим npm версии 1.2.14 или выше.**

Обо всем по порядку.

## Ускорение сборки bem make / server

В новой версии bem-tools 0.6.4 увеличена скорость сборки bem make / server.

Прирост скорости будет зависеть от каждого конкретного проекта. Как показывают результаты тестов, величина прироста может быть от нескольких процентов до десятка раз.

Пример project-stub, использующий v2 на [Github](https://ru.bem.info/tutorials/project-stub).

Чтобы получить ускорение сборки в bem make, необходимо на собираемом проекте использовать новые модули технологий (v2).

Новые технологии немного отличаются от старых по API. При наследовании технологий все модули в цепочке должны быть одной версии (старые не должны перемешиваться с новыми).

Для перехода на новые технологии нужно в файле `.bem/level.js` бандлов задекларировать их, например:

```js
exports.getTechs = function() {

    return {
        'bemjson.js'     : '',
        'js'             : 'v2/js-i',
        'bemdecl.js'     : 'v2/bemdecl.js',
        'deps.js'        : 'v2/deps.js',
        'i18n'           : '../bem-bl/blocks-common/i-bem/bem/techs/v2/i18n.js',
        'i18n.js'        : '../bem-bl/blocks-common/i-bem/bem/techs/v2/i18n.js.js',
        'css'            : 'v2/css'
    };
};
```

Для новых технологий указываются те же пути, что и для старых, за исключением префикса `v2/`. Это касается технологий, которые идут в составе bem-tools, и тех, которые входят в [bem-bl](https://ru.bem.info/libs/bem-bl/). Старые модули с новой версией bem-tools будут работать без изменений скорости.

В [bem-bl 0.3](https://github.com/bem/bem-bl/tree/0.3) есть все необходимое для использования v2.

Встречаются проекты, на которых технологии по умолчанию не прописаны в уровнях. В этом случае будут использоваться старые версии. Чтобы использовать новые, их нужно прописать явно, как показано в примере выше.

При использовании новых технологий дополнительное ускорение можно получить за счет кеширования уровней переопределения с блоками.

Если вы работаете над проектом, в котором подключается bem-bl (или другая библиотека блоков), блоки которой вы не меняете, а правите блоки на других уровнях, то сборку можно настроить таким образом, чтобы bem-bl просканировалась единожды, и при последующих сборках использовался кеш с диска.

Это можно сделать с помощью следующего кода в `.bem/make.js`

```js
MAKE.decl('Arch', {
    getLevelCachePolicy: function() {
        return {
                cache: false,
                except: ['bem-bl']
        }
    }

});
```

Здесь `cache:false` говорит, что по умолчанию кеш уровней выключен.

А `except` — массив путей уровней (или директорий, содержащих уровни), для которых будет действовать исключение, т.е. в данном случае кеш будет включен.

Кеш регенерируется, если сборка запущена с опцией `--force`.

## Изменения в API

### 1. Настройка своей технологии для использования нового API

Чтобы ваша технология использовала новый API, нужно экспортировать свойство API_VER:

```js
exports.API_VER = 2;

exports.techMixin = {

...

};
```

### 2. Настройка расширений файлов (суффиксов), с которыми работает технология

В старых технологиях для указания суффиксов, которые и из которых технология будет строить результат, использовались методы: `getSuffixes()`, `getBuildSuffixes()`. В новых можно использовать те же методы, но для большей гибкости и простоты понимания лучше использовать `getBuildSuffixesMap()`.

```js
{
    getBuildSuffixesMap: function() {
        return {
            'ie.css': ['ie.css', 'ie.hover.css'];
        }
    }
}
```

В этом примере мы говорим, что будем собирать файл `ie.css` из файлов `ie.css` и `ie.hover.css`. Ключей в возвращаемом объекте может быть больше одного, если технология собирает несколько файлов.

### 3. Изменения сигнатуры методов в базовом классе технологии

| v1        | v2           |
| ------------- |-------------|
|buildByDecl(decl, levels, output)|buildByDecl(decl, levels, output, opts)|
|getBuildResult(prefixes, suffix, outputDir, outputName)|getBuildResult(files, suffix, output, opts)|
|getBuildResults(prefixes, outputDir, outputName)|getBuildResults(decl, levels, output, opts)|
|getBuildPrefixes(decl, levels)|:x:|
|build(prefixes, outputDir, outputName)|:x:|
|filterPrefixes(prefixes, suffixes)|:x:|
|:x:|getBuildPaths(decl, levels)|
|:x:|saveLastUsedData(file, data)|
|:x:|getLastUsedData(file)|

  * Во всех методах, где встречается аргумент `opts`, — это хэш параметров, которые были переданы в `bem build`. В него же можно добавлять свои вспомогательные параметры.
  * Вместо пары outputDir, outputName передается один аргумент output, содержащий путь к файлу (без суффикса), который (-ые) будет (-ут) создаваться.
  * Вместо аргумента prefixes, который содержит пути к потенциально существующим на уровнях файлам, из которых будет происходить билд, передается аргумент files. Это массив файлов, которые существуют на уровнях и имеют суффиксы, подходящие для собираемой технологии. Элемент массива - это объект со свойствами:
    * file — имя файла.
    * absPath — абсолютный путь до файла.
    * lastUpdated — дата модификации файла.
    * suffix — суффикс файла.
  * getBuildPaths() по переданной декларации (decl) и списку уровней (levels) возвращает список существующих на них файлов, попадающих под декларацию. Список представлен в виде хэша, в котором файлы сгруппированы по суффиксу технологии.

Например:

```js
{
    css: [{...}, {...}, {...}],
    js: [{...}, {...}],
    bemhtml: [{...}, {...}, {...}, {...}]
}
```
  * saveLastUsedData(file, data)/getLastUsedData(file) сохраняет или загружает список файлов, из которых технология строила файл (file) в последний раз. Используется для валидации: нужно строить файл, или же он уже существует, и был построен из тех же файлов, из которых может быть построен сейчас.

Стандартный ход выполнения методов v2 технологии выглядит так:

<img src="https://img-fotki.yandex.ru/get/15566/158800653.1/0_111ffa_4cae794c_orig"/>

Точкой входа является `buildByDecl()`. Он вызывает `getBuildResults()`, результат работы которого - это хэш, где ключ - суффикс файла, а значение - массив строк контента. Например, для технологии `i18n.js` он может выглядеть так:

```js
{
 'en.js': ['...', '...', ...],
 'ru.js': ['...', '...', '...', ...],
 'tr.js': ['...', '...', ...]
}
```

Этот хэш передается в `storeBuildResults()`, который сохраняет контент в файлы.

Чтобы построить хэш, `getBuildResults()` получает список файлов (через вызов `getBuildPaths()`), которые есть на используемых уровнях переопределения, и которые подходят для собираемой технологии. То есть суффиксы которых соответствуют тому, что прописано в `getBuildSuffixesMap()` технологии. Дальше для каждого суффикса (в случае с i18n.js это en.js, ru.js и т.д) вызывается `getBuildResult()`. Ему передается список файлов, отфильтрованный по конкретному суффиксу.

Каждый путь файла обрабатывается `getBuildResultChunk()`, где на выходе получается строка-контент.

В зависимости от технологии это может быть просто полученный путь файла, обернутый в директиву подключения, или прочитанный с диска контент этого файла.

**Stay BEMed!**
