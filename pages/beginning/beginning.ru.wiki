=== Что такое БЭМ?
В Яндексе свёрстали множество проектов, счёт страниц идёт на десятки тысяч. Подходы,
применяемые разработчиками Яндекса к HTML/CSS-вёрстке и клиентскому коду вообще,
постоянно эволюционировали.

Проекты, разрабатываемые в Яндексе, и процессы их разработки имеют ряд особенностей:

 * Типовые проекты должны разрабатываться быстро, но жить долго\\
   Нужно уметь за короткий срок создать проект, архитектура которого позволит без
   труда поддерживать и развивать его долгие годы.
 * Над проектом работает много людей\\
   Нужно уметь эффективно организовывать работу команд, как из 1–2 разработчиков,
   так и из десятков.
 * Масштабируемость команд\\
   Добавление новых людей в команду должно улучшать производительность. Необходима
   возможность быстро вводить новых разработчиков в курс дела и выделять им
   собственные зоны ответственности.\\
   Для того, чтобы с одним и тем же кодом можно было работать долгое время и разным
   составом команды, код должен быть хорошо структурирован.
 * Повторное использование кода\\
   Каждый новый проект или фича не должны писаться с нуля. Если где-то внутри
   компании уже выполнялась похожая задача, нужно максимально повторно использовать
   полученный в результате код.

Мы искали решения возникающих перед нами проблем. Начиная с какого-то момента, эти
решения составили ##методологию БЭМ##.\\
Один из самых распространённых примеров методологии в программировании – это ООП.
ООП – парадигма программирования, применимая во многих языка. Точно также и методология
БЭМ – способ описания действительности в коде, набор паттернов и способ думать о
сущностях вне зависимости от того, на каком языке программирования это реализуется.\\
На основе этой методологии разработаны подходы к вёрстке и технические решения,
которые позволяют нам быстро создавать новые страницы и легко поддерживать уже
существующие.

##БЭМ## расшифровывается как Блок-Элемент-Модификатор, смысл этих терминов раскрыт
ниже.\\
В этой статье описаны теоретические аспекты подходов к web-разработке, применяемых в
Яндексе. Помимо теории у нас, конечно, есть и практические разработки библиотек и
инструментов. Ссылки на них представлены в тексте статьи как дополнительные материалы.

Итак, каким принципам отвечают наш код и процессы разработки:

=== Единая предметная область
Представьте обычный сайт. Например, такой как на картинке.

%%html
<div style="text-align:center">
<img src="images/site.png"/>
</div>
%%

При разработке и развитии сайта удобно мысленно выделить «блоки», из которых сайт
состоит.\\
Например, на этом макете есть ##Шапка##, ##Основной лайаут## и ##Подвал##. Шапка в свою
очередь состоит из ##Логотипа##, ##Поиска##, ##Блока авторизации## и ##Меню##. Основной
лайаут содержит ##Заголовок страницы## и ##Блок текста##.

%%html
<div style="text-align:center">
<img src="images/site-marked.png"/>
</div>
%%

Если у каждой части сайта есть название, этими терминами удобно пользоваться при общении
внутри команды. Менеджер может попросить
 * увеличить ##Шапку##, или
 * Сделать ещё одну страницу, где в ##Шапке## нет ##Поиска##

Можно попросить JavaScript-разработчика
 * Сделать ##Блок авторизации## анимированным, и т.д.

Итак,

==== Блок
Мы называем блоком некоторую самостоятельную сущность, кирпичик проекта. Блок может быть
простым или составным, то есть содержать в себе другие блоки.

**Пример**\\
Блок поисковой формы\\

%%html
<div style="text-align:center">
<img src="images/search-block.png"/>
</div>
%%

====Элемент
Элемент – это какая-то часть блока, отвечающая за отдельную функцию. Элемент может
находиться только в составе блока и не имеет смысла в отрыве от него.

**Пример**\\
Поле ввода и кнопка — элементы блока

%%html
<div style="text-align:center">
<img src="images/search-block-marked.png"/>
</div>
%%

===Cредства описания страницы и шаблоны
Блоки и элементы – это обозначение содержания страницы. Помимо факта присутствия
конкретных блоков на странице, важно также их расположение.

Блоки (или элементы) могут идти друг за другом в определённом порядке:

Например, товары в интернет-магазине:

%%html
<div style="text-align:center">
<img src="images/goods-list.png"/>
</div>
%%

Или пункты меню:

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

Блоки могут быть вложены друг в друга:

Например, блок Шапка содержит другие блоки:

%%html
<div style="text-align:center">
<img src="images/head-marked.png"/>
</div>
%%


Чтобы быстро изменять содержание страницы, добавлять новые блоки, перемещать их друг
относительно друга, нужен способ описания страницы в виде текста. Для этого необходимо,
чтобы каждому блоку или элементу соответствовало ключевое слово.

Ключевое слово, обозначающее конкретный блок, называется ##именем блока##.

Например, ##menu## для меню или ##head## для шапки сайта.

Ключевое слово, обозначающее элемент, называется ##именем элемента##.

Например, каждый пункт меню – это элемент ##item## блока ##menu##.

Имя блока должно быть уникальным, из него однозначно следует, о каком блоке идёт речь.
Одинаковые имена могут быть только у одинаковых блоков. В этом случае мы говорим о том,
что один блок представлен на странице 2 (3, 4, ...) раза.

Имя элемента должно быть уникальным только в пределах блока. Элемент может повторяться
в блоке несколько раз. Например, пункты меню.

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

Такие ключевые слова нужно размещать в определённом порядке. Для этого подойдут форматы
данных с использованием вложенности. Например, XML или JSON:

%%hl xml
<b:page>
  <b:head>
    <b:menu>
      ...
    </b:menu>
    <e:column>
      <b:logo/>
    </e:column>
    <e:column>
      <b:search>
        <e:input/>
        <e:button>Search</e:button>
      </b:search>
    </e:column>
    <e:column>
      <b:auth>
        ...
      </b:auth>
    <e:column>
  </b:head>
</b:page>
%%

В данном примере пространства имён ##b## и ##e## использованы, чтобы отделять узлы про
блоки от узлов про элементы.

То же самое в JSON:

%%hl js
{
  block: 'page',
  content: {
    block: 'head',
    content: [
      { block: 'menu', content: ... },
      {
        elem: 'column',
        content: { block: 'logo' }
      },
      {
        elem: 'column',
        content: [
          {
            block: 'search',
            content: [
              { elem: 'input' },
              {
                elem: 'button',
                content: 'Search'
              }
            ]
          }
        ]
      },
      {
        elem: 'column',
        content: {
          block: 'i-auth',
          content: ...
        }
      }
    ]
  }
}
%%

На примерах выше приведена объектная модель с вложенностью блоков и элементов в другие
блоки. Также в описании страницы присутствуют произвольные данные.\\
Такую структуру мы назваем ##БЭМ-деревом## (по аналогии с DOM-деревом).

Конечный HTML для браузера получается из БЭМ-дерева страницы путём наложения шаблонов
(например, XSL-шаблоны или JavaScript).

Если разработчику нужно переместить блок в другое место на странице, это делается при
помощи изменения дерева. Конечный вид шаблоны сделают сами.

В своих последних разработках мы ориентируемся на JSON как формат описания страницы. Он
превращается в HTML при помощи JavaScript-based шаблонизатора.\\
Ссылки на конкретные инструменты можно найти в конце статьи.

=== Независимость блоков

Во время разработки или поддержки долгоживущего проекта, может возникнуть желание
переместить блок. Например, стоит задача

 * Поменять местами ##Логотип## и ##Блок авторизации##, или
 * Разместить ##Меню## под ##Поиском##

%%html
<div style="text-align: center">
<img src="images/head.png"/>
</div>
%%

%%html
<div style="text-align: center">
<img src="images/head-changed.png"/>
</div>
%%

Для того, чтобы легко выполнять эти просьбы, блоки должны быть ##независимыми##.

##Независимый## блок свёрстан так, чтобы его можно было вставить в любое место на странице.
В том числе и вставить в другой блок.

====Независимый CSS

С точки зрения CSS для блока, это означает, что

 * У блока (или элемента) должно быть уникальное «имя», на которое можно написать CSS
   правило. Например, соответствующий CSS-класс.
 * Не должно быть CSS-селекторов на теги
 * Не нужно писать каскадные селекторы из нескольких блоков

=====Пример схемы именования независимых CSS-классов

Одна из возможных схем именования CSS-классов, удовлетворяющая требованиям, такая:

 * CSS-класс блока совпадает с ##именем блока##
%%hl xml
<ul class="menu">
  ...
</ul>
%%
 * CSS-класс элемента — это ##имя блока## и ##имя элемента##, разделённые
 определённым символом (или символами)
%%hl xml
<ul class="menu">
  <li class="menu__item">
    ...
  </li>
  <li class="menu__item">
    ...
  </li>
</ul>
%%
Необходимость учитывать имя блока в CSS-классе для элемента нужна для минимизации каскада.

Правила именования CSS-классов могут быть и другими. О том, какие соглашения об именовании
используются нами, можно прочесть ((http://bem.github.com/bem-bl/pages/naming/naming.ru.wiki здесь)).

====Независимые шаблоны

С точки зрения шаблонного движка, независимость блоков означает, что:

 * Блоки и элементы должны иметь описание во входных данных\\
   У блока (или элемента) должно быть уникальное «имя», чтобы при передаче данных шаблонному движку
   можно было сказать «здесь нужно разместить Меню».
 * Блок может быть легко помещён в любое место в БЭМ-дереве

===== Пример независимых шаблонов для блоков
Встречая во входных данных описание блока, шаблон должен однозначно преобразовывать его в
нужный HTML. Для этого у каждого блока должен быть свой шаблон.

Например, в XSL это может выглядеть так:
%%hl xml
<xsl:template match="b:menu">
  <ul class="menu">
    <xsl:apply-templates/>
  </ul>
</xsl:template>

<xsl:template match="b:menu/e:item">
  <li class="menu__item">
    <xsl:apply-templates/>
  </li>
<xsl:template>
%%

В своих собственных разработках мы постепенно отказываемся от XSL в пользу собственного
JavaScript-based шаблонного движка ((https://github.com/veged/xjst XJST)). Этот шаблонизатор вобрал в
себя всё то, что нам нравилось в XSL, но реализует это с производительностью JavaScript как на
сервере, так и на клиенте.\\
Мы пишем шаблоны для блоков на преметно-ориентированном языке (domain specific language) BEMHTML, в
основе которого лежит XJST.
((http://clubs.ya.ru/bem/replies.xml?item_no=992 Основные понятия шаблонизатора BEMHTML)) опубликованы в клубе БЭМ.

=== Повторяемость блоков
На сайте может появиться второй блок ##Меню##, например в ##Подвале##. Или два блока ##Текст##,
разделённых рекламной вставкой.\\
Даже если блок проектировался как единственный, на странице в любой момент может появиться второй
такой же.

С точки зрения CSS это обозначает, что:
 * Для CSS-селекторов не используются селекторы с ID\\
   Вместо них удобно использовать классы

С точки зрения JavaScript это обозначает, что:

 * Блоки, которым требуется одинаковое поведение, могут быть однозначно определены: у них
одинаковый CSS-класс\\
   Используя селекторы класса, можно выбрать все одинаковые блоки на странице и задать им нужное
   динамическое поведение.

===Модифицируемость блоков и элементов
Может возникнуть ситуация, в которой требуется не просто повторить блок, но и в внести в него
незначительные изменения.\\
Например, стоит задача:
 * Сделать в подвале ещё одно меню, с //другим дизайном//.

%%html
<div style="text-align: center">
<img src="images/site-footer-menu.png"/>
</div>
%%

Чтобы не разрабатывать рядом блок, минимально отличающийся от уже существующего, нужно
воспользоваться ##модификатором##.

##Модификатор## — это свойство блока или элемента, которое немного меняет внешний вид или поведение.\\
Модификатор имеет имя и значение. Одновременно может использоваться несколько разных модификаторов.

**Приммер**\\
Модификатор блока задаёт ему цвет фона

%%html
<div style="text-align: center">
<img src="images/search-background.png"/>
</div>
%%

**Пример**\\
Модификатор элемента для текущего пункта меню изменяет эго внешний вид

%%html
<div style="text-align: center">
<img src="images/menu-current-item.png"/>
</div>
%%

С точки зрения входных-данных:
 * В БЭМ-дереве модификаторы представлены как свойства той сущности, которая описывает блок или элемент

Например, в XML это могут быть атрибуты соответствующего узла:

%%hl xml
<b:menu m:type="big" m:type="buttons">
  ...
</b:menu>
%%

То же самое в формате JSON:

%%hl js
{
  block: 'menu',
  mods: [
   { size: 'big' },
   { type: 'buttons' }
  ]
}
%%

C точки зрения CSS:
 * Модификатор представляется дополнительным CSS-классом блока или элемента.

%%hl xml
<ul class="menu menu_size_big menu_type_buttons">
  ...
</ul>
%%

%%hl js
.menu_size_big {
  // CSS code to change height
}
.menu_type_buttons .menu__item {
  // CSS code to change item's view
}
%%

Модифицируемость элементов реализуется по аналогии.

Например, модификатором можно обозначить текущий пункт меню:

%%hl xml
<b:menu>
  <e:item>Index<e:item>
  <e:item m:state="current">Products</e:item>
  <e:item>Contact<e:item>
</b:menu>
%%

%%hl js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'Index' },
    {
      elem: 'item',
      mods: { 'state' : 'current' },
      content: 'Products'
    },
    { elem: 'item', content: 'Contact' }
  ]
}
%%

%%hl xml
<div class="menu">
  <ul class="menu__layout">
    <li class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </li>
  </ul>
</div>
%%

%%hl js
.menu__item_state_current {
  font-weight: bold;
}
%%

=== Предметная абстракция
Если над проектом работает много людей, им нужно договариваться о предметной области. У всех блоков
проекта должны быть однозначные имена, которые используются в коде.

Например, реализованный на сайте блок ##Облаго тегов## всегда называется ##tags##, а каждый элемент
(метка) в нём - ##tag##. Это справедливо для любой технологии: CSS, JS, XSL etc.

С точки зрения процесса разработки:
 * Все участники процесса оперируют одними терминами

С точки зрения CSS:
 * CSS блоков и элементов можно описывать на псевдо-языке, который затем компилируется в чистый
   CSS согласно принятой схеме именования.

%%hl js
  .menu {
    __layout {
      display: inline;
    }
    __layout-item {
      display: inline-block;
      ...
    }
    __item {
      _state_current {
        font-weight: bold;
      }
    }
  }
%%

С точки зрения JavaScript:
 * Не нужно обращаться к DOM-узлам блоков и элементов по имени класса

%%hl js
$('menu__item').click( ... );
$('menu__item').addClass('menu__item_state_current');
$('menu').toggle('menu_size_big').toggle('menu_size_small');
%%

Схема именования CSS-классов для блоков и элементов может измениться. При использовании специальных
JavaScript-функций для обращения к блокам и работы с их модификаторами, нужно будет внести изменения
только в эти функци

%%hl js
Block('menu').elem('item').click( ... );
Block('menu').elem('item').setMod('state', 'current');
Block('menu').toggleMod('size', 'big', 'small');
%%

Приведённый здесь код - абстрактный. В реальных разработках мы используем JavaSscript-ядро блока
##i-bem## из библиотеки bem-bl: ((http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html))

=== Консистентность блока
На нашем сайте реализован блок Кнопка, у которого есть динамическое поведение.

%%html
<div style="text-align: center">
<img src="images/button.png"/>
</div>
%%

При наведении курсора на этот блок он меняет свой внешний вид.

%%html
<div style="text-align: center">
<img src="images/button-cursor.png"/>
</div>
%%

Менеджер может попросить:
 * Использовать такую же кнопку на другой странице

Просто CSS-реализации блока недостаточно. Ведь в данном случае, чтобы полностью повторить блок, нужно
повторить и его поведение, описанное в JavaScript.

Таким образом, блок должен знать о себе всё. То есть реализация блока подразумевает описание его
внешнего вида и поведения во всех необходимых дехнологиях. Этот принцип мы называем ##мультилингвальность##.

##Мультилингвальность## - это описание блока на всех языках (технологиях), необходимых для его работы.

Если блок нужно прредставить на странице, у него должны быть реализованы технологии:
 * шаблоны (XSL, TT2, JavaScript, и т.д.), превращающие декларацию блока на странице в HTML-код
 * CSS, отвечающий за внешний вид блока

Когда у блока также есть динамическое поведение, к этому списку добавляются:
 * JS-реализация блока

В список технологий входит всё, что относится к блоку, в том числе и:
 * Картинки блока

=== Представление блоков на файловой системе
==== Однозначное положение кода
===== Именование файлов
Если проект
 * живёт долго и постоянно обрастает новыми сущностями

Если команда разработки
 * состоит из нескольких специалистов
 * растёт и изменяется (появляются новые люди)

нужен способ быстро определять, где может находится код блока.

Код блока легко искать, если он расположен в файлах, одноимённых ключевому слову блока:

%%html
<pre>
menu.xsl
menu.js
menu.css
</pre>
%%

===== Файловая независимость блока
Может возникнуть задача
 * использовать несколько блоков предыдущего проекта на новом проекте

Чтобы легко делать это, реализацию блока (во всех технологиях) нужно уметь доставлять в
другое место. Это может быть сделано при помощи копирования файлов или частичным чекаутом
репозитория проекта-донора. И в том и в другом случае удобно, чтобы все файлы, относящиеся
к блоку, были объединены в одну папку:

%%html
<pre>
menu/
  menu.xsl
  menu.js
  menu.css
</pre>
%%

===== Файловая структура блока
В процессе работы над проектом может возникнуть необходимость изменить какой-то блок.

Менеджер может попросить:
 *  Изменить цвет ##активному пункту Меню##, или
 *  Сделать ##Меню## реагирующим на наведение курсора

Один разработчик может попросить другого:
 *  Помочь с вёрсткой ##Поисковой формы## под IE

Чтобы можно было сразу понять, где лежит код, о котором идёт речь, нужно соблюдать в
разработке следующие требования:
 * Код блока размещён в отдельной директории
   * Имя директории совпадает с именем блока
   * Техническая реализация блока размещена в файлах в директории блока
 * Элементу соответствует под-директория в директории блока
   * Имя директории совпадает с именем элемента 
   * Техническая реализация элемента располагается в файлах в этой директории
 * Модификатору соответствует под-директория в директории блока
   * Имя директории соответствует имени модификатора
   * Техническая реализация модификатора размещается в файлах в этой директории
   * Названия файлов содержат как имя, так и значение модификатора

**Пример**\\
Файловая структура блока Меню

%%html
<pre>
menu/
  __item/
    _state/
      menu__item_state_current.css
      menu__item_state_current.xsl
    menu__item.css
    menu__item.xsl
  menu.css
  menu.js
  menu.xsl
</pre>
%%

Поддерживать такую файловую структуру вручную неудобно. Для работы с файлами мы используем
((https://github.com/bem/bem-tools БЭМ-инструменты)). Это набор утилит, позволяющий создавать
файлы по определённым шаблонам и с определённой схемой расположения на файловой системе.

===== Группировка блоков в папки
На большом портале необходимо реализовывать одни и те же блоки на разных проектах.

Может возникнуть задача:
 * Реализовать одинаковый Подвал ##на всех проектах Портала##, или
 * Сделать  ##новый проект##, используя блоки уже существующего

Разработка сайтов один за другим в web-студии часто подразумевает использование типовых решений для типовых страниц.

Менеджер может попросить:
 * Сделать Страницу заказа товара с формой ##как на позапрошлом проекте##

Выполнять эти задачи нужно, не копируя блоки из проекта в проект. Должна быть возможность
подключить блоки одного проекта к другому. Для этого блоки нужно объединять в одну директорию.

Мы называем такую директорию ##blocks##.

**Пример**

%%html
<pre>
blocks/
  foot/
  head/
  menu/
  page/
  search/
</pre>
%%

Такую папку можно подключить к новому проекту прямо из репозитория. Так, код блока будет храниться
только в одном месте. Если нужно внести изменения или починить баг, это нужно будет сделать только там.

==== Уровни переопределения
Если группа блоков одного проекта (объединённая в папку) подключена к другому проекту напрямую
(при помощи частичного чекаута или svn:externals), то любое закоммиченное изменение в таких блоках
повлияет на оба проекта.

При разработке одного сайта на основе существующего может потребоваться:
 * Увеличить шрифт в Шапке на всём сайте (не затрагивая предыдущий сайт),
 * Добавить анимацию для раскрытия всех выпадающих меню.

То есть необходима возможность переопределять (или доопределять) блоки в разных технологиях только
для определённого сайта или только для определённых страниц. Это возможно благодаря ##уровням переопределения##.

##Уровень переопределения## — это набор реализаций блоков, сгруппированных в одну директорию.

%%html
<div style="text-align:center;">
<img src="images/levels-schema.png"/>
</div>
%%

Реализация любого блока библиотеки может быть расширена (или переопределена) на уровне проекта.

%%html
<div style="text-align:center;">
<img src="images/block-levels.png"/>
</div>
%%

С точки зрения сборки страниц:
 * При сборке каждой страницы можно указать список уровней (директорий), блоки которых будут
   представлены на странице. Например,\\
   ##build-page -l blocks-common -l blocks-my my-page.html##

С точки зрения файловой структуры:
 * Проект можно содержать любое количество реализаций блоков. Но на страницу попадут только те,
   которые явно указаны к применению для сборки этой страницы. Возможно делать разные наборы
   уровней переопределения для разных разделов сайтов.

С точки зрения JavaScript
 * Необходима возможность декларативного описания динамического поведения элементов на странице.
   Конечное поведение должно собираться с разных уровней переопределения. Например,

%%hl js
/* blocks-common/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    ...
  }
});

/* blocks-my/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    this.__base();
    ...
  }
});
%%

С точки зрения шаблонного движка
* Для того, чтобы можно было не только переопределять, но и "доопределять" шаблон, нужна
   возможность вызвать предыдущую реализацию шаблона.\\
   Например, в случае xsl:

%%hl xml
<xsl:template match="b:head">
  <div> <!-- Node for extra design -->
    <xsl:apply-imports/>
  </div>
</xsl:template>
%%

С точки зрения архитектуры проекта

 * При разработке портала из нескольких сайтов можно выделить общую библиотеку блоков, которая станет
   одним из уровней переопределения для всех сайтов портала. Блоки конкретного сайта — объединить в
   другой уровень переопределения.
 * В одном и том же репозитории, может храниться реализация сайта для десктопным и мобильных браузеров.\\
   В таком проекте есть уровень переопределения для общей реализации блоков, для мобильной и для десктопной.
   Различные комбинации уровней дают желаемую реализацию блоков на конкретных страницах.

Примером реализации нескольких уровней переопределения в одном репозитории может служить
((https://github.com/bem/bem-bl Open Source библиотека блоков bem-bl)).


