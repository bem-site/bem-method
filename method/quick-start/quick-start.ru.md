# Быстрый старт

## Введение

БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке.
В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая копипаста.

##  Содержание

* [Блок](#Блок)
* [Элемент](#Элемент)
* [Когда создавать блок, когда элемент?](#Когда-создавать-блок-когда-элемент)
* [Модификатор](#Модификатор)
* [Микс](#Микс)
* [Зачем писать имя блока в именах модификаторов и элементов?](#Зачем-писать-имя-блока-в-именах-модификаторов-и-элементов)
* [Файловая система](#Файловая-система)

## Блок

Функционально независимый компонент страницы, который может быть повторно использован. В HTML блоки представлены атрибутом `class`.

Особенности:

* [Название блока](../naming-convention/naming-convention.ru.md#Имя-блока) характеризует смысл («что это?» — «меню»: `menu`, «кнопка»: `button`), а не состояние («какой, как выглядит?» — «красный»: `red`, «большой»: `big`).

**Пример**
```html
<!-- Верно. Семантически осмысленный блок `error`  -->
<div class="error"></div>
<!-- Неверно. Описывается внешний вид -->
<div class="red-text"></div>
```

* Блок не должен влиять на свое окружение, т. е. блоку не следует задавать внешнюю геометрию (в виде отступов, границ, влияющих на размеры) и позиционирование. В CSS по БЭМ также не рекомендуется использовать селекторы по тегам или `id`. Таким образом обеспечивается независимость, при которой возможно повторное использование или перенос блоков с места на место.

### Принцип работы с блоками

#### Вложенность

 * Блоки можно вкладывать друг в друга.
 * Допустима любая вложенность блоков.

**Пример**

```html
<!-- Блок `header`  -->
<header class="header">  
    <!-- Вложенный блок `logo` -->
    <div class="logo"></div>  
    <!-- Вложенный блок `search-form` -->
    <form class="search-form"></form>  
</header>
```

## Элемент

Составная часть блока, которая не может использоваться в отрыве от него.

Особенности:

* [Название элемента](../naming-convention/naming-convention.ru.md#Имя-элемента) характеризует смысл («что это?» — «пункт»: `item`, «текст»: `text`), а не состояние («какой, как выглядит?» — «красный»: `red`, «большой»: `big`).
* Структура полного имени элемента соответствует схеме: `имя-блока__имя-элемента`. Имя элемента отделяется от имени блока двумя подчеркиваниями (`__`).

**Пример**

```html
<!-- Блок `search-form` -->
<form class="search-form">   
    <!-- Элемент `input` блока `search-form` -->
    <input class="search-form__input">  
    <!-- Элемент `button` блока `search-form` -->
    <button class="search-form__button">Найти</button>  
</form>
```
### Принципы работы с элементами

* [Вложенность](#Вложенность)
* [Принадлежность](#Принадлежность)
* [Необязательность](#Необязательность)

####  Вложенность

* Элементы можно вкладывать друг в друга.
* Допустима любая вложенность элементов.
* Элемент — всегда часть блока, а не другого элемента. Это означает, что в названии элементов не рекомендуется прописывать иерархию вида `block__elem1__elem2`.

**Пример**

```html
<!-- Верно. Структура полного имени элементов соответствует схеме: `имя-блока__имя-элемента` -->
<form class="search-form">   
    <div class="search-form__content">  
        <input class="search-form__input">  
        <button class="search-form__button">Найти</button>  
    </div>
</form>
<!-- Неверно. Структура полного имени элементов не соответствует схеме: `имя-блока__имя-элемента` -->
<form class="search-form">  
    <div class="search-form__content">  
        <!-- Рекомендуется: `search-form__input` или `search-form__content-input` -->
        <input class="search-form__content__input">
        <!-- Рекомендуется: `search-form__button` или `search-form__content-button` -->
        <button class="search-form__content__button">Найти</button>  
    </div>
</form>
```

В методологии БЭМ вложенную структуру поддерживают только блоки (`block__elem`). Имя блока задает пространство имен, которое [гарантирует зависимость](../naming-convention/naming-convention.ru.md#Имя-элемента) элементов от блока.

Блок может иметь вложенную структуру элементов в DOM-дереве:

**Пример**

```html
<div class="block">
    <div class="block__elem1">
        <div class="block__elem2">
            <div class="block__elem3"></div>
        </div>
    </div>
</div>
```

Однако эта же структура блока в методологии БЭМ всегда будет представлена плоским списком элементов:

**Пример**

```css
.block {}
.block__elem1 {}
.block__elem2 {}
.block__elem3 {}
```

Это позволяет изменять DOM-структуру блока без внесения правок в коде каждого отдельного элемента:

**Пример**

```html
<div class="block">
    <div class="block__elem1">
        <div class="block__elem2"></div>
    </div>
    <div class="block__elem3"></div>
</div>
```

Структура блока меняется, а правила для элементов и их названия остаются прежними.

#### Принадлежность

Элемент — **всегда часть блока** и не должен использоваться отдельно от него.

**Пример**

```html
<!-- Верно. Элементы лежат внутри блока `search-form` -->
<!-- Блок `search-form` -->
<form class="search-form">    
    <!-- Элемент `input` блока `search-form` -->
    <input class="search-form__input">  
    <!-- Элемент `button` блока `search-form` -->
    <button class="search-form__button">Найти</button>  
</form>
<!-- Неверно. Элементы лежат вне контекста блока `search-form` -->
<!-- Блок `search-form` -->
<form class="search-form"></form>
<!-- Элемент `input` блока `search-form` -->
<input class="search-form__input">  
<!-- Элемент `button` блока `search-form` -->  
<button class="search-form__button">Найти</button>  
```

#### Необязательность

Элемент — необязательный компонент блока. Не у всех блоков должны быть элементы.

**Пример**

```html
<!-- Блок `search-form` -->  
<div class="search-form">  
    <!-- Блок `input` -->
    <input class="input">  
    <!-- Блок `button` -->
    <button class="button">Найти</button>  
</div>
```

## Когда создавать блок, когда элемент?

1. Если фрагмент кода может использоваться повторно и не зависит от реализации других компонентов страницы, необходимо создавать блок.
2. Если фрагмент кода не может использоваться самостоятельно, без родительской сущности (блока), в большинстве случаев создается элемент.

Исключение составляют элементы, реализация которых для упрощения разработки требует разделения на более мелкие части — подэлементы. БЭМ-методология [не рекомендует создавать элементы элементов](#Вложенность). В подобном случае вместо элемента необходимо создавать служебный блок.

## Модификатор

Cущность, определяющая внешний вид, состояние или поведение блока либо элемента.

Особенности:

* [Название модификатора](../naming-convention/naming-convention.ru.md#Имя-модификатора) характеризует внешний вид («какой размер?», «какая тема?» и т. п. — «размер»: `size_s`, «тема»: `theme_islands`), состояние («чем отличается от прочих?» — «отключен»: `disabled`, «фокусированный»: `focused`) и поведение («как ведет себя?», «как взаимодействует с пользователем?» — «направление»: `directions_left-top`).
* Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (`_`).

### Типы модификаторов

#### Булевый

* Используют, когда важно только наличие или отсутствие модификатора, а его значение несущественно. Например, «отключен»: `disabled`. Считается, что при наличии булевого модификатора у сущности его значение равно `true`.
* Структура полного имени модификатора соответствует схеме:
  * `имя-блока_имя-модификатора`;
  * `имя-элемента_имя-модификатора`;

**Пример**

```html
<!-- Блок `search-form` имеет булевый модификатор `focused` со значением `true` -->
<form class="search-form search-form_focused">  
    <input class="search-form__input">  
    <!-- Элемент `button` имеет булевый модификатор `disabled` со значением `true` -->
    <button class="search-form__button search-form__button_disabled">Найти</button>  
</form>
```

#### Ключ-значение

* Используют, когда важно значение модификатора. Например, «меню с темой оформления `islands`»: `menu_theme_islands`.
* Структура полного имени модификатора соответствует схеме:
  * `имя-блока_имя-модификатора_значение-модификатора`;
  * `имя-элемента_имя-модификатора_значение-модификатора`.

**Пример**

```html
<!-- Блок `search-form` имеет модификатор `theme` со значением `islands`-->  
<form class="search-form search-form_theme_islands">  
    <input class="search-form__input">  
    <!-- Элемент `button` имеет модификатор `size` со значением `m` -->
    <button class="search-form__button search-form__button_size_m">Найти</button>  
</form>
```

### Принципы работы с модификаторами

#### Модификатор нельзя использовать самостоятельно

С точки зрения БЭМ-методологии модификатор не может использоваться в отрыве от модифицируемого блока или элемента. Модификатор должен изменять вид, поведение или состояние сущности, а не заменять ее.

**Пример**

```html
<!-- Верно. Блок `search-form` имеет модификатр `theme` со значением `islands`-->
<form class="search-form search-form_theme_islands">
    <input class="search-form__input">  
    <button class="search-form__button">Найти</button>  
</form>
<!-- Неверно. Отсутствует модифицируемый класс `search-form` -->
<form class="search-form_theme_islands">  
    <input class="search-form__input">  
    <button class="search-form__button">Найти</button>  
</form>
```

## Микс

Прием, позволяющий использовать разные БЭМ-сущности на одном DOM-узле.

Миксы позволяют:

* совмещать поведение и стили нескольких сущностей без дублирования кода;
* создавать семантически новые компоненты интерфейса на основе имеющихся.

**Пример**

```html
<!-- Блок `header`  -->
<div class="header">  
    <!-- К блоку `search-form` примиксован элемент `search-form` блока `header`-->
    <div class="search-form header__search-form"></div>  
</div>
```

В данном примере мы совместили поведение и стили блока `search-form` и элемента `search-form` блока `header`.
Такой подход позволяет нам задать внешнюю геометрию и позиционирование в элементе `header__search-form`, а сам блок `search-form` оставить универсальным.
Таким образом, блок можно использовать в любом другом окружении, потому что он не специфицирует никакие отступы. Это позволяет нам говорить о его независимости.

## Зачем писать имя блока в именах модификаторов и элементов?

Имя блока в именах модификаторов и элементов обеспечивает:

* [Пространство имен](#Пространство-имен)
* [Миксы](#Миксы)
* [Поиск в коде](#Поиск-в-коде)

____________________________________________

**Важно!** Методология БЭМ [допускает выбор](../method/naming-convention/naming-convention.ru.md#Альтернативные-схемы-именования) удобной стратегии именования, но требует соблюдения консистентности в названиях. Так, например, все варианты верны: `context`, `ctx` или `c`, `attributes`, `attrs` или `as`. Необходимо выбрать один из них и использовать во всем проекте.
_____________________________________________

### Пространство имен

Имя блока задает пространство имен и обеспечивает уникальность имен элементов и модификаторов. Это позволяет ограничить влияние элементов и модификаторов одного блока на реализацию другого.

### Миксы

При миксе модификатора имя блока указывает, к какому блоку применится модификатор. Если имя блока не указать, модификатор применится ко всем миксуемым БЭМ-сущностям.

Например, рассмотрим микс пункта меню (`menu__item`) и кнопки (`button`):

```html
<div class="menu__item button"></div>
```

Добавим модификатор `active` в сокращенной форме записи (без имени блока):

```html
<div class="menu__item button active"></div>
```

В таком виде HTML-разметка не дает понять, к чему относится модификатор: к пункту меню (`menu__item.active`) или к кнопке (`button.active`). Имя блока (`button_active`) явно указывает на БЭМ-сущность, к которой будет применен модификатор.

Также запись `<div class="block mod">` не дает понять, какие БЭМ-сущности используются в работе. Например, из записи `<div class="checkbox button">` нельзя однозначно определить, это микс модификатора и блока или микс двух блоков.

Полное имя модификатора `<div class="block block_mod">` показывает, о каких сущностях идет речь: `<div class="checkbox checkbox_button">`.

### Поиск в коде

Явные и уникальные имена облегчают поиск необходимой сущности в коде и файловой системе.

Сравним результаты глобального поиска при отладке проекта. Найдем модификатор `active`. В сокращенном виде (`active`) в результаты поиска попадут все возможные комбинации и HTML-фрагменты, где встречается `active`. В записи, рекомендуемой методологией, само название уже будет содержать уточняющий параметр в виде имени блока (`button_active`). Так как имя модификатора уникально, в результаты поиска попадут только нужные фрагменты кода.

## Файловая система

Принятый в методологии БЭМ компонентный подход применяется и к [организации проектов в файловой системе](../filesystem/filesystem.ru.md#Организация-файловой-системы). Реализации блоков, элементов и модификаторов делятся на независимые файлы-технологии, что позволяет нам подключать их опционально.

Особенности:

* Один блок — одна директория.
* Имена блока и его директории совпадают. Например, блок `header` — директория `header/`,  блок `menu` — директория `menu/`.
* Реализация блока разделяется на отдельные файлы-технологии. Например, `header.css`, `header.js`.
* Директория блока является корневой для поддиректорий соответствующих ему элементов и модификаторов.
* Имена директорий элементов начинаются с двойного подчеркивания (`__`). Например, `header/__logo/`,  `menu/__item/`.
* Имена директорий модификаторов начинаются с одинарного подчеркивания (`_`). Например, `header/_fixed/`, `menu/_theme_islands/`.
* Реализации элементов и модификаторов разделяются на отдельные файлы-технологии. Например, `header__input.js`, `header_theme_islands.css`.

**Пример**

```files
search-form/                           # Директория блока `search-form`
    __input/                           # Поддиректория элемента `search-form__input`
        search-form__input.css         # Реализация элемента `search-form__input` в технологии CSS
        search-form__input.js          # Реализация элемента `search-form__input` в технологии
                                         JavaScript
    __button/                          # Поддиректория элемента `search-form__button`
        search-form__button.css
        search-form__button.js
    _theme/                            # Поддиректория модификатора `search-form_theme`
        search-form_theme_islands.css  # Реализация блока `search-form`, имеющего модификатор
                                         `theme` со значением `islands` в технологии CSS
        search-form_theme_lite.css     # Реализация блока `search-form`, имеющего модификатор
                                         `theme` со значением `lite` в технологии CSS
search-form.css                        # Реализация блока `search-form` в технологии CSS
search-form.js                         # Реализация блока `search-form` в технологии JavaScript
```

Такая файловая структура позволяет легко поддерживать и повторно использовать код.

> Разветвленная файловая структура предполагает, что в production код будет [собираться в общие файлы проекта](../build/build.ru.md#Методология-сборки-БЭМ-проекта).

Придерживаться [рекомендуемой структуры файловой системы](../filesystem/filesystem.ru.md#Организация-файловой-системы-БЭМ-проекта) не обязательно. Вы можете использовать любую [альтернативную структуру проекта](../../faq/faq.ru.md#Зачем-создавать-отдельные-директории-и-файлы-для-каждого-блока-и-технологии).
