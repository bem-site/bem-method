# Часто задаваемые вопросы

## Почему БЭМ?

* [В чем отличие БЭМ от OOCSS, AMCSS, SMACSS, SUITCSS?](#bem-benefits)
* [В чем разница между БЭМ и Web Components?](#bem-vs-web-components)
* [В чем разница между БЭМ и Bootstrap?](#bem-vs-bootstrap)

## Блоки и элементы

* [В каком случае создавать блок, в каком — элемент?](#block-vs-elem)
* [Почему в БЭМ не рекомендуется создавать элементы элементов (`block__elem1__elem2`)?](#bem-elem-hierarchy)
* [Зачем писать имя блока в именах модификаторов и элементов?](#long-name)
* [Как сделать глобальные модификаторы для блоков?](#global-mod)
* [Зачем создавать отдельные директории и файлы для каждого блока и технологии?](#file-system)

## JavaScript

* [Зачем использовать `i-bem.js`, если можно писать на jQuery?](#i-bem-vs-JS)

## CSS

* [Почему нежелательны каскады CSS?](#css-cascade)
* [Почему в БЭМ не рекомендуется использовать комбинированные селекторы для создания CSS-правил к модификатору?](#comb-css)
* [Можно ли объединять тег и класс в селекторе (например, `button.button`)?](#tag-class-css)
* [Почему в БЭМ не используют пользовательские теги (custom tag) для блоков?](#tag-css)
* [Почему нельзя делать общий сброс стилей (reset)?](#global-reset)
* [Почему нельзя писать `<div class="block_mod">` вместо `<div class="block block_mod">`, если имя модификатора уже содержит всю информацию о блоке?](#block-name)
* [Почему нельзя указывать название CSS-свойства в имени модификатора: `.block__element_border-bottom_5px`)?](#value-css)


**Не нашли ответ?** — [Задайте вопрос команде на форуме](https://ru.bem.info/forum/)

<a name="bem-benefits"></a>
## В чем отличие БЭМ от OOCSS, AMCSS, SMACSS, SUITCSS?

1. БЭМ работает не только с CSS, но и с JavaScript.
1. БЭМ больше схож с Web Components, чем с перечисленными решениями для CSS. ([В чем разница между БЭМ и Web Components?](#bem-vs-web-components))
1. БЭМ предоставляет решения по созданию архитектуры проекта и помогает организовать процессы разработки.

>Подробнее о [методологии БЭМ](https://ru.bem.info/method/).

Можно использовать БЭМ  только на уровне CSS. Для этого достаточно просто следовать [рекомендациям методологии](../naming/naming.ru.md).

>[Решение распространенных проблем веб-разработки с помощью БЭМ](../fixed-problems.ru.md)

<a name="bem-vs-web-components"></a>
## В чем разница между БЭМ и Web Components?

Поддержка браузеров

* Web Components [не поддерживается](http://caniuse.com/#search=Web%20Components) в Safari, iOS Safari, Internet Explorer, Firefox.
* БЭМ работает во всех браузерах.

Инкапсуляция

* В Web Components реализована через Shadow DOM.
* В БЭМ - с помощью [элементов](../definitions/definitions.ru.md#elem) блока.

Работа шаблонов

* В Web Components шаблоны всегда выполняются в браузере, что вызывает проблемы с индексацией.
* В БЭМ генерация шаблона возможна на этапе разработки. Это позволяет отдавать готовый HTML и избежать проблем с индексацией. Шаблоны также могут выполнятся и в браузере.


* Web Components использует императивный принцип — интреполяцию строк.
* БЭМ использует декларативный принцип, который позволяет выразить в шаблонах большее количество сценариев.

Вместо импорта HTML — сборка

* Web Components использует импорт HTML (HTML Imports), который работает непосредственно в браузере. Требует вулканизации.
* БЭМ использует сборщики: [ENB](https://ru.bem.info/tools/bem/enb-bem-examples/) или [bem-tools](https://ru.bem.info/tools/bem/bem-tools/).

Вместо Custom Elements — абстракция над DOM-деревом

* В Web Components используются Custom Elements. Такой подход позволяет разместить на одном DOM-узел один компонент.
* В БЭМ существует понятие [БЭМ-дерева](../definitions/definitions.ru.md#bem-tree). БЭМ использует [миксы](../definitions/definitions.ru.md#mix) — размещение нескольких БЭМ-сущностей на одном DOM-узле.

<a name="bem-vs-bootstrap"></a>
## В чем разница между БЭМ и Bootstrap?

В терминах БЭМ [Bootstrap](http://getbootstrap.com/) — это набор  сверстанных блоков. БЭМ — не библиотека элементов интерфейса, а методология, позволяющая:

* создавать архитектуру проекта;
* разрабатывать веб-приложения независмыми блоками;
* упрощать поддержку проектов.

Библиотека блоков, сделанных на БЭМ — [bem-components](https://ru.bem.info/libs/bem-components/current/). Существуют также и [другие](https://ru.bem.info/libs/) БЭМ-библиотеки.

<a name="block-vs-elem"></a>
## В каком случае создавать блок, в каком элемент?

1. Если фрагмент кода может использоваться повторно и не зависит от реализации других компонентов страницы, необходимо создавать [блок](../definitions/definitions.ru.md#block).
1. Если фрагмент кода не может использоваться самостоятельно, без родительской сущности (блока), в большинстве случаев создается [элемент](../definitions/definitions.ru.md#elem).

Исключение составляют элементы, реализация которых для упрощения разработки требует разделения на более мелкие части — подэлементы. БЭМ-методология [не рекомендует делать элементы элементов](#bem-elem-hierarchy). В подобном случае вместо элемента необходимо создавать служебный блок.

<a name="bem-elem-hierarchy"></a>
## Почему в БЭМ не рекомендуется создавать элементы элементов (`block__elem1__elem2`)?

Наличие элементов элементов лишает возможности изменять внутреннюю структуру блока: элементы не могут быть поменяны местами, удалены или добавлены без корректировки существующего кода.

В БЭМ-методологии вложенную структуру поддерживают только блоки (`block__elem`). Имя блока задает пространство имен, которое [гарантирует зависимость](../namimg/naming/ru.md#bem-elem-name) элементов от блока.

Блок может иметь вложенную структуру элементов в DOM-дереве:

```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'>
            <div class='block__elem3'></div>
        </div>
    </div>
</div>
```

Однако эта же структура блока в БЭМ-методологии всегда будет представлена плоским списком элементов:

```css
.block{}
.block__elem1{}
.block__elem2{}
.block__elem3{}
```

Это позволяет изменять DOM-структуру блока без внесения правок в коде каждого отдельного элемента:

```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'></div>
    </div>
    <div class='block__elem3'></div>
</div>
```
Структура блока меняется, а правила для элементов и их названия остаются прежними.

<a name="long-name"></a>
## Зачем писать имя блока в именах модификаторов и элементов?

Имя блока в именах БЭМ-сущностей обеспечивает:

* [Пространство имен](#namespace)
* [Миксы](#mix)
* [Поиск в коде](#search)

> **Важно!** Методология БЭМ [допускает выбор](../naming/naming.ru.md#name-scheme) удобной стратегии именования, но требует соблюдения консистентности в названиях. Так, например, все варианты верны: `context`, `ctx` или `c`, `attributes`, `attrs` или `as`. Необходимо выбрать один из них и использовать во всем проекте.


>[Соглашение по именованию БЭМ](../naming/naming.ru.md)

<a name="namespace"></a>
#### Пространство имен

Имя блока задает пространство имен и обеспечивает уникальность имен элементов и модификаторов. Это позволяет ограничить влияние элементов и модификаторов одного блока на реализацию другого.

<a name="mix"></a>
#### Миксы

[Микс](../definitions/definitions.ru.md#mix) — это совмещение разных БЭМ-сущностей на одном DOM-узле. При миксе модификатора имя блока указывает, к какому блоку применится модификатор. Если имя блока не указать, модификатор применится ко всем миксуемым БЭМ-сущностям.

Например, рассмотрим микс пункта меню (`menu__item`) и кнопки (`button`):

```html
<div class="menu__item button"></div>
```

Добавим модификатор `active` в сокращенной форме записи (без имени блока):

```html
<div class="menu__item button active"></div>
```

В таком виде HTML-разметка не дает понять, к чему относится модификатор: к пункту меню (`menu__item.active`) или к кнопке (`button.active`). Имя блока (`button_active`) явно указывает на БЭМ-сущность, к которой будет применен модификатор.

Также запись `<div class="block mod">` не дает понять, какие БЭМ-сущности используются в работе. Например, из записи `<div class="checkbox button">` нельзя однозначно определить, это микс модификатора и блока или микс двух блоков.

Полное имя модификатора `<div class="block block_mod">` показывает, о каких сущностях идет речь: `<div class="checkbox checkbox_button">`.

<a name="search"></a>
#### Поиск в коде

Явные и уникальные имена облегчают поиск необходимой сущности в коде и файловой системе.

Сравним результаты глобального поиска при рефакторинге проекта. Найдем модификатор `active`. В сокращенном виде (`active`) в результаты поиска попадут все возможные комбинации и HTML-фрагменты, где встречается `active`. В записи, рекомендуемой методологией, само название уже будет содержать уточняющий параметр в виде имени блока (`button_active`). Так как имя модификатора уникально, в результаты поиска попадут только нужные фрагменты кода.

<a name="global-mod"></a>
## Как сделать глобальные модификаторы для блоков?

В БЭМ отсутствует понятие глобальных модификаторов, так как модификатор всегда относится к одной конкретной БЭМ-сущности.

Если требуется вынести CSS-свойство за пределы одного блока и применять его к разным БЭМ-сущностям в проекте, необходимо создавать отдельный блок, реализованный в технологии CSS.

БЭМ позволяет совмещать реализацию разных блоков с помощью [миксов](../definitions/definitions.ru.md#mix):

```html
<div class="block1 block2"></div>
```

<a name="file-system"></a>
## Зачем создавать отдельные директории и файлы для каждого блока и технологии?

Файловая система БЭМ-проекта разделяется на вложенные директории и файлы для удобства разработки и поддержки проекта.

Придерживаться [рекомендуемой структуры файловой системы](../filesystem/filesystem.ru.md#bem-file-system) не обязательно. Вы можете использовать любую альтернативную структуру проекта, соответствующую [принципам организации файловой системы БЭМ](../filesystem/filesystem.ru.md#principles), например:

**flex-схема**

* Блоку соответствует отдельная директория.
* Элементы и модификаторы реализованы в отдельных файлах.

```
blocks/
    input/
        input_layout_horiz.css
        input_layout_vertical.css
        input__elem.css
        input.css
        input.js
    button/
```

* Блоку соответствует отдельная директория.
* Элементы и модификаторы реализованы в файлах блока.

```
blocks/
    input/
        input.css
        input.js
    button/
```

* Директории для блоков не используются.
* Элементы и модификаторы реализованы в файлах блока.

```
blocks/
    input.css
    input.js
    button.css
    button.js

```
**flat-схема**

* Директории для блоков не используются.
* Опциональные элеметы и модификаторы реализованы в отдельных файлах.

```
blocks/
    input_type_search.js
    input_type_search.bemhtml
    input__box.bemhtml
    input.css
    input.js
    input.bemhtml
    button.css
    button.js
    button.bemhtml
    button.png
```

<a name="i-bem-vs-JS"></a>
## Зачем использовать `i-bem.js`, если можно писать на jQuery?

[i-bem.js](https://ru.bem.info/technology/i-bem/v2/i-bem-js/) это специализированный фреймворк для разработки проектов на JavaScript в терминах блоков, элементов и модификаторв.

`i-bem.js` не предназначен для замены фреймворка общего назначения, такого как jQuery.

`i-bem.js` позволяет:

* разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
* интегрировать JavaScript-код с шаблонами и CSS-правилами в стиле БЭМ;
* описывать логику работы блока как набор состояний.

<a name="css-cascade"></a>
## Почему нежелательны каскады CSS?

Ключевая идея БЭМ — независимость блоков. Каскады увеличивают связанность кода и делают его повторное использование невозможным. Это противоречит принципам БЭМ.

Методология БЭМ допускает использование каскадов, но рекомендует по-максимуму его сократить.

Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока или заданной ему темы:

```css
.nav_hovered .nav__link
{
    text-decoration: underline;
}
```
```css
.nav_theme_islands .nav__item
{
    line-height: 1.5;
}
```

<a name="comb-css"></a>
## Почему в БЭМ не рекомендуется использовать комбинированные селекторы для создания CSS-правил к модификатору?

Комбинированные селекторы усложняют переопределение блока, так как имеют более высокую специфичность в CSS, чем одиночные. Специфичность комбинированного селектора для модификатора блока (`.block1.mod`) и для переопределенного блока (`.block2 .block1`) одинакова. Переопределение блока будет зависеть только от порядка объявления правил в декларации.

Рассмотрим пример:

```html
<div class="header">
  <button class="button active">
</div>
```
Правила модификатора `active` для кнопки записываются, как комбинированный селектор `.button.active`. При переопределении кнопки с помощью родительского блока `header`, создается селектор `.header .button`. Специфичность обоих селекторов одинакова, значит применение CSS-правил определяется их порядком в декларации.

Использование имени блока в названии модификатора обеспечивает более высокий приоритет CSS-правилам при переопределении блока.
Селектор `.header .button` всегда будет иметь приоритет выше, чем `.button_active`.

>[Причины использования имени блока в имени модификатора](#short-mod-name)


<a name="tag-class-css"></a>
## Можно ли объединять тег и класс в селекторе? Например, `button.button`.

Совмещение тега и класса в селекторе повышает специфичность CSS-правил. При добавлении модификатора правила блока не смогут быть переопределены, так как специфичность селектора блока выше.

Рассмотрим пример:

```html
 <button class="button">
```

Записываем для него CSS-правила в селекторе `button.button`.

Добавим модификатор:

```html
 <button class="button button_active">
```

Cелектор `.button_mod` не переопределит свойства блока, записанные как `button.button`, так как специфичность `button.button` выше. Для успешного переопределения селектор модификатора блока также должен быть скомбинирован с тегом `button.button_mod`.

В результате развития проекта могут появится блоки с селекторами `input.button`, `span.button` и, например, `a.button`. В таком случае все модификаторы блока `button` и вложенные в него элементы потребуют четыре разные декларации для каждого случая.

<a name="tag-css"></a>
## Почему в БЭМ не используют пользовательские теги (custom tags) для блоков?

>Блоки могут выражаться в HTML с помощью пользовательских тегов, к которым создаются CSS-правила. В таком случае классы можно будет использовать только для модификаторов: `<button class="mod"/>`.

Пользовательские теги могут применяться для создания селекторов к блокам, но есть ряд ограничений:

* Невозможно использовать [миксы](../definitions/definitions.ru.md#mix).
* Не любой блок можно выразить пользовательским тегом. Например, для всех ссылок необходим тег `<a>`, а для полей — `<input>`.

<a name="global-reset"></a>
## Почему нельзя делать общий сброс стилей (reset)?

Блок — независимый компонент. На него не должны влиять CSS-правила, созданные для всей страницы. Это нарушает независимость блоков и затрудняет их повторное использование.

Общий сброс стилей по сути реализуется с помощью [глобальных CSS-правил](#global-mod), которые в большинстве случаев пишутся к [селекторам на тег](#tag-css), что нежелательно использовать в БЭМ-проекте.

Если сбросить стили все-таки необходимо, в БЭМ это делается в каждом блоке.

Рассмотрим пример. Если в проекте блоки меню и список выражены в HTML с помощью тега `<ul>`, значит каждый блок должен предоставлять сброс CSS для `<ul>`. Повторов в результирующем коде можно избежать с помощью CSS-оптимизатора.

Если в проекте не используется CSS-оптимизатор, который объединяет селекторы с одинаковым набором правил, можно применить CSS-препроцессор. Тогда для каждого нового блока можно делать сброс правил, миксуя чистый код. Например, в SASS это будет выглядеть так:

```
.menu {
    @include reset-list;
}
.menu__item {
    @include reset-list-item;
}
...
.list {
    @include reset-list;
}
.list__item {
    @include reset-list-item;
}
```

Такой способ следует использовать только при отсутствии оптимизатора.

<a name="block-name"></a>
## Почему нельзя писать `<div class="block_mod">` вместо `<div class="block block_mod">`, если имя модификатора уже содержит всю информацию о блоке?

Совмещение нескольких модификаторов на одном и том же блоке (например, `<div class="block_theme_christmas block_size_big">`) приведет к дублированию кода, реализующего базовую функциональность (логику и стили) блока.

<a name="value-css"></a>
## Почему нельзя указывать название CSS-свойства в имени модификатора: `.block__element_border-bottom_5px`?

* При изменении внешнего вида блока или элемента придется менять не только CSS-код, но и названия селекторов. Например, если граница изменится с 5px до 6px, нужно будет изменить шаблоны и, вполне вероятно, JavaScript-код.
* При добавлении других свойств (фона, отступов), имя перестанет соответствовать содержанию модификатора.

БЭМ-методология рекомендует выбирать имена модификаторов, опираясь на семантику, а не визуальное оформление.
