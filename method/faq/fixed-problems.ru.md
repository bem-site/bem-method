# Решение распространенных проблем веб-разработки с помощью БЭМ

БЭМ-методология задает [правила по именованию CSS-селекторов](../naming/naming.ru.md), соблюдение которых решает ряд проблем веб-разработки и отвечает на следующие вопросы:

* [Как упростить код и облегчить рефакторинг](#bem-simple-code)
* [Как получить самодокументируемый код](#bem-clarify-code)
* [Как начать повторно использовать код и избежать взаимного влияния компонентов друг на друга](#bem-split-code)
* [Как разместить несколько сущностей на одном DOM-узле и забыть про «копипаст»](#bem-mix)

<a name="bem-simple-code"></a>
## Как упростить код и облегчить рефакторинг

**Проблема**

При верстке проекта компоненты интерфейса получают имена на основе контекста, с которым работает разработчик. Обычно контекстом служит страница или какая-то ее часть.

Когда страницу верстает один разработчик в короткие сроки, коллизии имен можно избежать. Но если над проектом работают несколько человек или правки нужно внести спустя какое-то время, то отследить зависимые имена компонентов становится сложно. В больших проектах результатом правки одного класса может стать десяток «разъехавшихся» страниц.

Например, для создания навигационного меню могут использоваться следующие имена классов:

```html
<ul class="nav">
    <li class="item active"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

К ним могут быть написаны CSS-правила:

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

Если понадобится добавить на страницу другой компонент, содержащий пункты, то стили для нового `item` повлияют на пункты из навигационного меню.

Или предположим, что в навигационном меню нужно изменить правила класса `.active`. По имени непонятно, какие компоненты его используют. Может оказаться, что на другой странице существует, например, кнопка `<div class=«button active»>Нажми меня!</div>`. Тогда изменение правил для `.active` повлияет на стили этой кнопки.

Чтобы разобраться, можно ли безболезненно изменить стили для класса `.active`, разработчику придется просмотреть всю структуру страницы или проекта. Любое изменение потребует значительных временных затрат только на поиск зависимых компонентов.

**Решение**

Методология БЭМ решает проблему коллизии имен при помощи [соглашения по именованию CSS-классов](../naming/naming.ru.md), предоставляя всем компонентам и их составляющим уникальные имена.

Применение правил по именованию позволяет:

* задавать уникальные имена компонентам и их составляющим;
* отслеживать иерархические связи в пределах блока;
* упрощать восприятие кода;
* получать [самодокуметируемый код](#bem-clarify-code).

Рассмотрим тот же пример навигационного меню:

```html
<ul class="nav">
    <li class="item active"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

Но применим к нему правила именования БЭМ: класс `nav` будет обозначать имя блока, `nav__item` и `nav__link` — имена элементов, а `nav__item_active` — имя модификатора элемента `item`.

В таком случае запись будет следующей:

```html
<ul class="nav">
    <li class="nav__item nav__item_active"><a class="nav__link">One</a></span></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

И, соответственно, CSS будет иметь такой вид:

```css
.nav__item
{
    padding: 4px 10px;
    color: black;
}

.nav__item_active
{
    font-weight: bold;
    background: #ffc7c7;
}
```

Новые имена CSS-классов содержат всю информацию о структуре блока. А это значит, что больше не нужно просматривать HTML-код страницы. Cелектор всегда содержит знания о том, на какой блок или элемент влияют его правила (в данном случае на элемент `nav__item`). Разработчику не придется думать о возможном существовании кнопки `<div class=«button active»>Нажми меня!</div>`, так как еe CSS-правила по БЭМ-методологии будут записаны как `.button_active` и не будут зависеть от правил модификатора `active` для пункта меню (`nav__item_active`).

>Использование длинных имен имеет следующие недостатки:

>* Результирующий код весит больше. Эта проблема решается `gzip`, который сжимает повторяющиеся последовательности в именах.
>* Времени на написание классов тратится больше. Эту проблему помогают решить автозаполнение в редакторе и использование CSS-препроцессоров и шаблонизаторов, которые автоматически добавляют префиксы. Длинные имена классов предоставляют явные связи между составными частями компонентов. А это экономит время на погружение в архитектуру проекта.

<a name="bem-clarify-code"></a>
### Как получить самодокументируемый код

**Проблема**

При переходе на новый проект разработчик тратит много усилий на то, чтобы понять, как все устроено, где что лежит и как работает. Порой именно на такое изучение уходит большая часть времени, а вовсе не на реализацию функциональности или исправление ошибки. В поддержке кода важно минимизировать время на знакомство с проектом.

**Решение**

Одна из целей БЭМ — дать понять, что делает тот или иной код, только по названиям классов. Идея самодокументируемого кода заключается в том, чтобы при просмотре CSS-классов, переменных и функций было понятно, как работает код, и как взаимодействуют компоненты интерфейса.

Используя БЭМ, можно получить HTML с именами классов, рассказывающих о взаимодействии разных частей кода:

* независимых [блоков](../definitions/definitions.ru.md#bem-block);
* дочерних компонентах — [элементах](../definitions/definitions.ru.md#bem-elem) этого блока;
* а что-то может видоизменять блок или элемент — [модификатор]](../definitions/definitions.ru.md#bem-mod).

Рассмотрим пример с формой поиска на сайте. Не будем обращаться к HTML, попробуем прочитать только CSS и понять, какую часть интерфейса он описывает.

Для начала представим как бы форма могла быть реализована в классической верстке:

```css
form {}

input
{
    bacground: red;
}

input[type=submit]
{
    background: buttonface
}
```

Такой способ записи не дает разработчику никаких сведений о взаимодействии компонентов: невозможно определить, к чему относятся данные селекторы. А использование глобальных селекторов делает код проекта нерасширяемым, так как внесение минимальных изменений повлечет за собой правки во всех зависимых правилах.

Попытаемся немного изменить данный код — напишем CSS на классы:

```css
.form {}
.field {}
.submit {}
```

Код стал информативнее: теперь понятно, что есть форма, поле и какой-то компонент `submit`. Но такие имена все еще не дают понять, относится ли поле (`field`) к форме (`form`), или что произойдет, если полей или форм на странице будет несколько. Снова возникает необходимость обращаться к HTML.

Перепишем пример, используя БЭМ:

```css
.form {}
.form_search {}
.form__field {}
.form__submit-button {}
```

Такая запись дает понимание того, как работает данный код. Только из имен CSS-классов видно, что:

* Существует некая форма, реализованная блоком `form`.
* Форма представлена уже не просто как абстрактная сущность: модификатор `form_search` указывает на то, что речь идет о форме поиска.
* У формы есть составляющие — вложенные элементы: поле `form__field` и кнопка `form__submit-button`.

Следование [соглашению по именованию сущностей](../naming/naming.ru.md) БЭМ позволяет понять структуру блока без подробного изучения HTML. Даже при появлении на странице еще одного поля (кроме `form__field`), его правила никак не будут влиять на элементы поисковой формы. Новое поле будет реализовано, как элемент нового блока и будет иметь свое специфичное имя. Например, `attach__field`.

Правила именования в БЭМ позволяют сделать код вашего проекта однозначным и, как следствие, информативным. Это снижает порог входа для других разработчиков: не прилагая дополнительных усилий вы получаете самодокументируемый код.

<a name="bem-split-code"></a>
## Как начать повторно использовать код и избежать взаимного влияния компонентов друг на друга

**Проблема**

Для создания каждой новой страницы проекта разработчик использует примерно одни и те же компоненты. Так, различных типов одного и того же блока `menu` в проекте или на странице может быть несколько.

Чтобы наглядно показать проблему, рассмотрим пример с навигационным меню:

```html
<ul class="nav">
    <li class="item"><a class="link">One</a></li>
    <li class="item"><a class="link">Two</a></li>
    <li class="item"><a class="link">Three</a></li>
</ul>
```

CSS-стили к пункту `item` в нем, скорее всего, будут записаны как:

```css
.item
{
    padding: 4px 10px;
    color: black;
}
```

Если на страницу понадобится добавить дополнительные компоненты, содержащие пункты, то появится еще один блок кода с классом `item`, например:

```html
<div class="snippets">
    <div class="item">
        <h2 class="title"></h2>
        <img class="thumb">
    </div>
</div>
```

Вероятность того, что CSS-правила будут оформлены с помощью каскада возрастает. Такой подход кажется вполне удобным и логичным: необходимо просто доопределить правила, уже написанные для `item`:

```css
.item
{
    padding: 4px 10px;
    color: black;
}

.snippets .item
{
    color: red;
    font-size: 14px;
}
```

Подобный код может безболезненно существовать и работать до тех пор, пока не возникнет необходимость изменить страницу. Например, переместить какие-то пункты меню, использовать написанный код в другом месте отдельно от родительского компонента или вложить навигационное меню в блок `snippets`.

При попытке осуществить хотя бы одно из таких действий, разработчик столкнется с проблемой, что на первый взгляд независимые части кода слишком связаны и влияют друг на друга. Используя каскады, нет возможности исправить один компонент, не затронув так или иначе стили другого.

**Решение**

[Правила по именованию CSS-селекторов](..naming/naming.ru.md) в БЭМ дают возможность вносить изменения точечно, не ломая зависимые компоненты. В БЭМ каждый компонент имеет уникальное имя и является самодостаточным.

Запишем тот же код в соответствии с правилами именования БЭМ:

```html
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

```css
.nav__item
{
    padding: 4px 10px;
    color: black;
}
```

В таком случае добавление нового пункта `item` на страницу будет выглядеть так:

```html
<div class="snippets">
    <div class="snippets__item">
        <h2 class="snippets__title"></h2>
        <img class="snippents__thumb">
    </div>
</div>
```

Пункт `snippets__item` будет иметь соответствующие только ему уникальные CSS-правила:

```css
.snippets__item
{
    padding: 4px 10px;
    color: red;
    font-size: 14px;
}
```

Внесенные изменения в `nav__item` никак не отобразятся на пункте `snippets__item`.

Таким образом, элемент `item` получает уникальные независимые CSS-стили благодаря [неймспейсам](https://ru.wikipedia.org/wiki/Пространство_имён) в виде имен блоков. Такой подход дает возможность защитить элементы от взаимного влияния друг на друга, так как они всегда являются частью блока. Такой же принцип работы использует и Shadow DOM в Web Components. Но, в отличие от Shadow DOM, применение БЭМ-нотации не зависит от поддержки браузеров.

В таком виде блоки `snippets` и `nav` можно повторно использовать и перемещать по странице или проекту. Уникальность имен классов, основанная на правилах именования БЭМ, позволяет блокам не зависеть друг от друга.

Независимость блоков касается не только CSS. В БЭМ блок является абсолютно самодостаточной единицей. Он знает о себе все: свой внешний вид (CSS), поведение (JavaScript) и шаблоны и перечень блоков, с которыми ему необходимо взаимодействовать (зависимости).

### Использование каскадов в БЭМ

В предыдущей главе описаны проблемы использования каскадов, но методология БЭМ их все же не отрицает.

Например, каскад уместен, чтобы менять элементы в зависимости от состояния блока или заданной ему темы:

```
.nav_hovered .nav__link
{
    text-decoration: underline;
}
```

```
.nav_theme_islands .nav__item
{
    line-height: 1.5;
}
```

Применение каскада увеличивает связанность кода и делает его повторное использование невозможным.

<a name="bem-mix"></a>
## Миксы, или как разместить несколько сущностей на одном DOM-узле и избежать «копипаста»

**Проблема**

В любых проектах возникают ситуации, когда можно применить уже реализованную функциональность в другом компоненте.

Во многих случаях такую проблему решают копированием нужной части кода в новый компонент. Такой подход имеет два минуса:

* увеличивается кодовая база проекта;
* затрудняется отладка кода при выявлении ошибки.

Разработчик вынужден поддерживать большее количество строк кода, вносить правки в каждую отдельную реализацию, что увеличивает временные затраты на отладку проекта.

**Решение**

Воспользуемся примером, который реализует универсальный блок навигационного меню и написан по всем [правилам именования БЭМ](../naming/naming.ru.md).

```
<ul class="nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

Такой блок можно применить в совершенно различных случаях. Например, может возникнуть необходимость использовать его для навигации по статьям в блоке новостей.

Допустим, в разделе новостей уже есть блок `articles`, которому написаны все необходимые CSS-правила.

Смешать реализации двух разных блоков без копирования кода можно при помощи [микса](../definitions/definitions.ru.md#bem-mix). То есть смешать на одном DOM-узле блок `nav` и элемент `articles__nav`.

В коде это будет выглядеть так:

```html
<ul class="nav articles__nav">
    <li class="nav__item"><a class="nav__link">One</a></li>
    <li class="nav__item"><a class="nav__link">Two</a></li>
    <li class="nav__item"><a class="nav__link">Three</a></li>
</ul>
```

Такая реализация будет содержать всю функциональность блока `nav` и особенности реализации элемента `articles__nav` — внешний вид новостных статей в меню. При этом нет необходимости копировать уже имеющиеся правила. А при обнаружении ошибки, правки необходимо будет внести только в одну часть кода.

>Точно также миксовать можно не только блоки с элементами, но и другие БЭМ-сущности. Подробнее о вариантах использования миксов в БЭМ читайте в разделе [Определения](../definitions/definitions.ru.md#bem-mix).
