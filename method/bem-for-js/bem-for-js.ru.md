# JavaScript по БЭМ

В БЭМ-методологии JavaScript используется для «оживления» веб-страницы и рассматривается как одна из [технологий реализации](../key-concepts/key-concepts.ru.md#Технология-реализации) блока.

Как и к любой другой технологии (например, к CSS) к JavaScript применяются основные принципы методологии БЭМ:

* [Единая предметная область](#Единая-предметная-область)
* [Разделение кода на части](#Разделение-кода-на-части)
  * [Принцип инкапсуляции](#Принцип-инкапсуляции)
  * [Принцип наследования](Принцип-наследования)
* [Работа с уровнями переопределения и использование сборки](#Работа-с-уровнями-переопределения)

Особенности реализации JavaScript по БЭМ-методологии рассматриваются в следующих разделах:

* [Работа с блоками](#Работа-с-блоками)
  * [Взаимодействие блоков](#Взаимодействие-блоков)
  * [Взаимодействие блока с его элементами](#Взаимодействие-блока-с-его-элементами)
[Работа с модификаторами](#Работа-с-модификаторами)
  * [Реакция на изменение модификаторов](#Реакция-на-изменение-модификаторов)
* [Представление динамических блоков в DOM](#Представление-динамических-блоков-в-DOM)
  * [Блоки с DOM-представлением](#Блоки-с-DOM-представлением)
  * [Блоки без DOM-представления](#Блоки-без-DOM-представления)
* [Как перейти на JavaScript по БЭМ](#Как-перейти-на-JavaScript-по-БЭМ)

## Единая предметная область

В БЭМ для работы с JavaScript используются термины «Блок», «Элемент» и «Модификатор».

JavaScript-реализация блоков не привязывается к DOM-элементам страницы, а использует следующий уровень абстракции — [БЭМ-дерево](../key-concepts/key-concepts.ru.md#БЭМ-дерево). Это позволяет не опираться на классы и независимо описывать поведение блоков и их опциональных элементов.

Поведение блоков и элементов задается с помощью модификаторов. Установка/снятие модификатора изменяет поведение блока.

Использование единой предметной области во всех технологиях обеспечивает взаимодействие с компонентами на более высоком уровне. Появляется возможность:
* реализовать различные хелперы для работы с компонентами;
* отказаться от жесткого кодирования имен блоков и разделителей. 

На практике это позволяет находить внутри блока все элементы с определенным именем и выставлять им модификатор, проверять его значение. 

**Пример**

Необходимо показать всплывающее окно (блок `popup`).

Один из наиболее распространенных способов – добавить соответствующий класс и жестко прописать имя блока в коде. 

```js
document.querySelector('.button')
.addEventListener('click', function() {
  document.querySelector('.popup').classList.toggle('popup_visible');
}, false);
```

В БЭМ-проекте нет необходимости хардкодить имя блока. Поиск компонента выполняется не по классу, а по имени блока, так как имя блока уникально. Сам компонент может выражаться не только классом, но и тегом, атрибутом и т.д. Отображение всплывающего окна также не зависит от класса: блок переводится в состояние `visible` с помощью модификатора. 

```js
block('button').click(function() {
  block('popup').toggleMod('visible');
});
```

> **Важно** Для примеров, написанных по БЭМ-методологии, используется псевдокод. Реальные примеры реализации представлены в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/v2/i-bem-js/).

## Разделение кода на части

В БЭМ-методологии поведение каждого блока описывается независимо.

К JavaScript применяются основные принципы организации и хранения кода:
* разделение кода на отдельные части — логика работы каждого блока, его опциональных элементов и модификаторов описывается в отдельных файлах;
* JavaScript-файлы для каждого компонента хранятся в соответствии с [правилами организации файловой структуры](../filestructure/filestructure.ru.md) БЭМ-проекта.

**Пример**

Рассмотрим пример логотипа (блок `logo`), реализованного в технологии CSS.

Блок `logo` в файловой структуре проекта:

```files
logo/           # Директория блока logo
    logo.css    # Реализация блока logo в технологии CSS
``` 

Добавим блоку `logo` новую функциональность: нажатие на логотип будет вызывать какое-то действие. 

JavaScript-реализация блока `logo`:

```js
document.querySelector('.logo').addEventListener('click', doSomething, false);
```

Файл `logo.js` в файловой структуре блока `logo`:

```files
logo/           # Директория блока logo
    logo.css    # Реализация блока logo в технологии CSS
    logo.js     # Реализация блока logo в технологии JavaScript
```

Разделение кода на части и строгая организация файловой структуры проекта позволяют:

* облегчить навигацию по проекту;
* повторно использовать блоки;
* [использовать уровни переопределения](#Работа-с-уровнями-переопределения) для технологии JavaScript.

#### Принцип инкапсуляции 

В БЭМ JavaScript-реализация одного блока отделена от другого. Каждый блок предоставляет API для [взаимодействия с другими блоками](#Взаимодействие-блоков).

Декларация блока позволяет скрыть его внутреннюю реализацию. Так как элементы всегда являются внутренней реализацией блока, [обращение к ним](#Взаимодействие-блока-с-его-элементами) возможно только через API самого блока.

#### Принцип наследования

Декларативное описание поведения блоков позволяет использовать методы базового блока внутри производного, наследовать их. Новый блок может получать все свойства и методы базового.

Также можно создавать цепочки наследования — блок наследуется от другого, который, в свою очередь, наследуется от третьего и т.д.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js-decl/#Наследование-блока).

### Работа с уровнями переопределения

Логика работы блока описывается декларативно: как набор действий и условий, при которых эти действия необходимо выполнять. Это позволяет разделять функциональность блока на отдельные части и использовать [уровни переопределения](../key-concepts/key-concepts.ru.md#Уровень-переопределения).

Разделение по уровням обеспечивает возможность:

* реализовывать новое поведение блока на другом уровне переопределения, сохраняя предыдущее, наследовать и дополнять его (делать super call);
* полностью перекрывать поведение блока (переопределять);
* добавлять блоки с новым поведением.

С помощью уровней переопределения можно создать универсальную JavaScript-библиотеку блоков и изменять ее на проектном уровне. Затем использовать сборку и включать в проект только необходимое поведение блоков.

**Пример**

Рассмотрим пример формы отправки сообщения.

```js
block('button').onSetMod({
    focused: {
        true: this.onFocus,
        '': this.onBlur
    }
});
```

Запись в БЭМ-терминах позволяет:

* Полностью перекрывать поведение блока на другом уровне переопределения.

  ```js
  block('button').onSetMod({
      focused: {
          true: this.someCustomOnFocused  // Полное изменение поведение блока
      }
  });
  ```

* Добавлять или частично изменять поведение блока на другом уровне переопределения.

  ```js
  block('button').onSetMod({
      focused: {
          true: function() {
              this.__base.apply(this, arguments); // Частичное изменение поведения блока
              this.someCustomOnFocused();
          }
      }
  });
  ```

> Для работы с JavaScript в БЭМ-терминах и использования уровней переопределения в БЭМ создан специализированный фреймворк [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js/).

## Работа с блоками

### Взаимодействие блоков

БЭМ-методология предполагает работу с независимыми блоками. Однако на практике полная независимость блоков недостижима.

Блоки могут взаимодействовать друг с другом с помощью:

* Подписки на события других экземпляров блоков.
* Подписки на изменения модификаторов.
* Непосредственного вызова методов других экземпляров блоков или статических методов класса другого блока.
* Любых паттернов взаимодействия. Например, канала событий: все коммуникации происходят благодаря сообщениям, которые компоненты публикуют и слушают с помощью посредника.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js-interaction/).

БЭМ-методология рекомендует выстраивать взаимодействие между блоками в иерархическом порядке в соответствии с их расположением в DOM-дереве. Вложенный блок не должен ничего знать о родительском блоке, так как это нарушает принцип независимости компонентов.

### Взаимодействие блока с его элементами

Элемент — это внутренняя реализация блока.
В БЭМ-методологии принято реализовывать дополнительные хелперы блока для работы с его элементами. Обращение напрямую к элементу другого блока невозможно. Взаимодействие с элементом происходит только через API блока, которому принадлежит данный элемент.

## Работа с модификаторами

Поведение блока описывается с помощью состояний. Модификаторы содержат всю информацию о состояниях блока. Перевод блока в другое состояние производится при помощи установки/снятия модификатора. Изменение модификатора создает событие, которое можно использовать для работы с блоком.

Например, чтобы отметить чекбокс, блоку `checkbox` нужно установить модификатор `checked` в значение `true`.

Для корректной работы JavaScript в БЭМ-проекте все манипуляции с модификаторами должны производиться при помощи методов-хелперов. Нельзя изменять состояния в режиме runtime с помощью модификатора, напрямую меняя CSS-класс на соответствующем DOM-узле. 
> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js-mods/).

### Реакция на изменение модификаторов

В БЭМ реакция на установку/снятие модификатора описывается декларативно: изменение состояния автоматически вызывает код, который задекларирован для этого состояния. Если появляется модификатор (добавляется новый класс к DOM-узлу), то вся функциональность, свойственная этому модификатору, также применяется. Если модификатор исчезает, функциональность отключается.

Переход блока из одного состояния в другое часто сопровождается изменениями его внешнего вида. Если изменение состояния блока вызвано модификатором, в котором определен и внешний вид блока, то при установке этого модификатора изменится не только поведения блока, но и автоматически применятся новые стили. 

Чтобы динамически изменять состояния блоков и элементов, используются специальные методы для установки и снятия модификаторов.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/v2/i-bem-js-mods/).

**Пример**

Рассмотрим форму отправки сообщения, в которой выполняется следующее условие: если введен неправильный email, кнопка отправки (блок `button`) становится недоступна (получает модификатор `button_disabled`).

Один из способов решения этой задачи — жестко прописать все условия в коде и постоянно выполнять проверку. Такой подход не удобен, так как любое изменение потребует изменений в коде вручную.

Другой способ — использовать методологию БЭМ и задекларировать поведение блока таким образом, чтобы получить возможность перекрывать каждый модификатор отдельно на новом уровне переопределения. В [декларации](https://ru.bem.info/technology/i-bem/current/i-bem-js-decl/) можно указать, как блок или элемент должен отреагировать на изменение модификатора.

```js
block('button').onSetMod({
    focused: {
        true: this.onFocus,
        '': this.onBlur
    }
});
```

Такой подход дает возможность:
* Реагировать на модификатор независимо от способа его установки/снятия (через JavaScript API: `block('button').setMod('focused')` или если пользователь установил/снял фокус вручную).
* Определять каждому состоянию свой внешний вид, добавив стили модификатору.
* Изменять или полностью перекрывать поведение блока с помощью [уровней переопределения](#Работа-с-уровнями-переопределения).

## Представление динамических блоков в DOM

### Блоки с DOM-представлением

Блокам с JavaScript-реализацией могут соответствовать узлы в HTML. В этом случае говорится о том, что **блоки имеют DOM-представление**.

В простейшем случае блок соответствует DOM-узлу один к одному. Однако DOM-узел и блок — это не всегда одно и то же. Можно разместить несколько блоков на одном DOM-узле (это называется [микс](../key-concepts/key-concepts.ru.md#Микс)), а также реализовать один блок на нескольких DOM-узлах.

### Блоки без DOM-представления

Инфраструктурный код, решающий общие задачи интерфейса (связь с бэкэндом, вспомогательные методы), может быть оформлен в виде блока без DOM-представления. Это позволит выражать состояния блока с помощью модификаторов, на изменение которых смогут подписаться другие блоки. В JavaScript они представлены в виде объектов, имеющих свои методы.

> Примеры реализации доступны в документации к [i-bem.js](https://ru.bem.info/technology/i-bem/current/i-bem-js-decl/#Синтаксис-декларации).

## Как перейти на JavaScript по БЭМ

Чтобы реализовать принципы БЭМ в проекте, необходимо:

* работать в единых терминах блоков, элементов и модификаторов во всех технологиях;
* создавать независимые компоненты — блоки — на уровне JavaScript;
* описывать поведение блока как набор действий и условий их выполнения;
* обращаться к элементам блока только через API самого блока и не нарушать принцип инкапсуляции;
* изменять поведение блоков, элементов и модификаторов с помощью уровней переопределения по аналогии с CSS;
* разделять код на мелкие независимые части для удобства работы с отдельными блоками;
* повторно использовать блоки.

Чтобы начать использовать JavaScript по БЭМ в рабочем проекте, можно начать применять принципы БЭМ-методологии без использования специализированного фреймворка. Пример проекта с JavaScript по БЭМ на jQuery описан в статье [БЭМ — это не только про CSS](https://ru.bem.info/forum/163/).
