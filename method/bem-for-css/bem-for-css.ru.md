# CSS по БЭМ

CSS в БЭМ используется для стилизации страниц и рассматривается как одна из [технологий реализации](../key-concepts/key-concepts.ru.md#Технология-реализации).

## Основные принципы компонентного подхода в CSS по БЭМ
* [Форматирование элементов посредством классов/Селекторы классов](#Форматирование-элементов-посредством-классовСелекторы-классов)
* [Совмещение тега и класса в селекторе](#Совмещение-тега-и-класса-в-селекторе)
* [Вложенные селекторы](#Вложенные-селекторы)
* [Именование селекторов](#Именование-селекторов)
* [Работа с модификаторами](#Работа-с-модификаторами)
* [Миксы](#Миксы)
 * [Внешняя геометрия и позиционирование](#Внешняя-геометрия-и-позиционирование)
 * [Стилизация групп тегов](#Стилизация-групп-блоков)
* [Разделение кода на части](#Разделение-кода-на-части)
 * [Принцип единственной ответственности](#Принцип-единственной-ответственности)
 * [Принцип открытости/закрытости](#Принцип-открытостизакрытости)
 * [DRY](#dry)
 * [Композиция вместо наследования](#Композиция-вместо-наследования)
* [Разделение кода по уровням переопределения и использование сборки](#Работа-с-уровнями-переопределения)

## Форматирование элементов посредством классов/Селекторы классов

Стили блоков и элементов в БЭМ описываются через селекторы классов.

Каждый HTML элемент должен иметь атрибут `class`.

**Пример**

HTML-реализация:

```html
<button class="button">...</button>
```

CSS-реализация:

```css
.button {}  
```

Один и тот же класс можно назначить любому количеству элементов на странице, что позволяет переиспользовать блоки.

**Пример**

```html
<header>
    <button class="button">...</button>
</header>
<main>
    <button class="button">...</button>
</main>
<footer>
    <button class="button">...</button>
</footer>
```

**Важно!** В БЭМ не используют селекторы тегов и идентификаторов.

### Множественные классы

В HTML значением атрибута `class` может быть разделенный пробелами список слов.

**Пример**

```html
<button class="button button_theme_islands">...</button>
```

Множественные классы делают возможным применение миксов и модификаторов. Особенности их реализаций в CSS мы рассмотрим ниже.

## Совмещение тега и класса в селекторе

Совмещение тега и класса в селекторе повышает специфичность CSS-правил.

Рассмотрим пример:

```html
 <button class="button">...</button>
```

Записываем для него CSS-правила в селекторе `button.button`.

Добавим модификатор:

```html
 <button class="button button_active">...</button>
```

Система приоритетов стилевых селекторов работает так:

* Селектор тегов имеет значимость 1 пункт.
* Селектор классов — 10 пунктов.
* ID-селектор — 100.
* Встроенный (inline) стиль — 1000.

Следовательно, селектор `.button_active` не переопределит свойства блока, записанные как `button.button`, так как специфичность `button.button` равна 11 (10 — для названия класса и 1 — для селектора тега), а `.button_active` — 10. Для успешного переопределения селектор модификатора блока также должен быть скомбинирован с тегом `button.button_active`.

В результате развития проекта могут появиться блоки с селекторами `input.button`, `span.button` и, например, `a.button`. В таком случае все модификаторы блока `button` и вложенные в него элементы потребуют четыре разные декларации для каждого случая.

## Вложенные селекторы

Ключевая идея БЭМ — независимость блоков. Вложенные селекторы увеличивают связность кода и делают его повторное использование невозможным. Это противоречит принципам БЭМ.

Методология БЭМ допускает использование таких селекторов, но рекомендует по максимуму их сократить.

Например, вложенность уместна, если нужно изменить стили элементов в зависимости от состояния блока или заданной ему темы:

**Пример**

```css
.button_hovered .button__text
{
    text-decoration: underline;
}
.button_theme_islands .button__text
{
    line-height: 1.5;
}
```

## Именование селекторов

Общие [правила именования блоков, элементов и модификаторов](../naming-convention/naming-convention.ru.md) позволяют независимо описывать стили блоков и их опциональных элементов.

**Пример**

```html
<button class="button button_theme_islands">
    <span class="button__text">Найти</span>
</button>
```

Именование CSS-классов:

```css
.button {}                  /* CSS-класс блока */
.button__text {}            /* CSS-класс элемента блока */
.button_theme_islands {}    /* CSS-класс модификатора блока */
```

## Работа с модификаторами

Модификаторами в БЭМ принято задавать блокам определенный внешний вид, состояние и поведение. Изменение оформления блока производится при помощи установки/снятия модификатора.

**Пример**

HTML-реализация:

```html
<button class="button button_size_s">...</button>
```

CSS-реализация:

```css
.button {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;
}

.button_size_s {
    font-size: 13px;
    line-height: 24px;
}

.button_size_m {
    font-size: 15px;
    line-height: 28px;
}

```
Преимущество в том, что мы можем изменять представление блока, точечно переопределяя необходимые для этого CSS-свойства.

Например, так:

```html
<button class="button button_size_s">...</button>
<button class="button button_size_m">...</button>
```

Таким образом, использование модификаторов избавляет нас от ненужного «Copy-Paste».

## Миксы
* [Внешняя геометрия и позиционирование](#Внешняя-геометрия-и-позиционирование)
* [Стилизация групп тегов](#Стилизация-групп-блоков)

### Внешняя геометрия и позиционирование

В CSS по БЭМ, стили, отвечающие за внешнюю геометрию и позиционирование, принято задавать через родительский блок.

Рассмотрим следующий пример:

**Пример**

HTML-реализация:

```html
<!-- Блок `header`  -->
<header class="header">  
    <button class="button">...</button>  
</header>
<!-- Блок `form`  -->
<form class="form" >
</form>
```

**Задача:** необходимо использовать эту же кнопку в блоке `form`.

CSS-реализация кнопки:

```css
.button {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;
    border: 4px solid black;    /* Рамка */
    margin: 30px;               /* Отступ */
}
```

Как видно, у блока `button` есть отступ в `30px`, который может помешать нам его переиспользовать.

Решение проблемы выглядит следующим образом:

**Пример**

HTML-реализация:

```html
<!-- Блок `header`  -->
<header class="header">  
    <!-- К блоку `button` добавили класс `header__button`-->
    <button class="button header__button">...</button>  
</header>
<!-- Блок `form`  -->
<form class="form" >
    <button class="button">...</button>  
</form>
```

CSS-реализация кнопки:

```css
.button {
    font-family: Arial, Helvetica, sans-serif;
    border: 4px solid black;    /* Рамка */
}
```

CSS-реализация элемента `button` блока `header`:

```css
.header__button {
    margin: 30px;
    position: relative;
}
```

В данном примере, мы задали внешнюю геометрию и позиционирование для блока`button` через элемент `header__button`, а сам блок `button` сделали универсальным.
Блок стал абсолютно независимым, потому что он не специфицирует никакие отступы.

**Абсолютно независимые блоки** позволяют делать удивительные вещи:

Блок `button`:

```html
<button class="button button_theme_islands">
    <span class="button__text">Найти</span>
</button>
```

Блок `menu`:

```html
<div class="menu">
    <div class="menu-item">Блок</div>
    <div class="menu-item">Элемент</div>
    <div class="menu-item">Модификатор</div>
</div>
```

Блок `popup`:

```html
<div class="popup"></div>
```

Всё как следует перемешиваем — блок `button` + блок `menu` + блок `popup` = блок `select`:

```html
<div class="select">
  <button class="button select__button">
      <span class="button__text">Блок</span>
  </button>
</div>
<div class="popup">
    <div class="menu">
        <div class="menu-item">Блок</div>
        <div class="menu-item">Элемент</div>
        <div class="menu-item">Модификатор</div>
    </div>
</div>

```

### Стилизация групп блоков

Иногда бывает необходимо применить одинаковое форматирование сразу к нескольким различным элементам веб-страницы.
Например, нужно, чтобы все заголовки имели один и тот же цвет и шрифт.

**Пример**

HTML-реализация:

```html
<section>
  <h1>Заголовок первого уровня</h1>
  <h2>Заголовок второго уровня</h2>
</section>
<section>
  <h1>Заголовок первого уровня</h1>
  <h2>Заголовок второго уровня</h2>
</section>
```

Обычно для решения подобных задач применяют групповые селекторы.

```css
h1, h2 {
    font-family: Arial, Helvetica, sans-serif;
    color: #ccc;
}
```

Несмотря на то, что групповые селекторы позволяют быстро изменить дизайн страницы, такой подход увеличивает связность кода.

Поэтому, в БЭМ для того, чтобы единообразно отформатировать целый набор тегов, используют миксы.

**Пример**

HTML-реализация:

```html
<section>
  <h1 class="title section-title">Заголовок первого уровня</h1>
  <h2 class="title section-title">Заголовок второго уровня</h2>
</section>
<section>
  <h1 class="title section-title">Заголовок первого уровня</h1>
  <h2 class="title section-title">Заголовок второго уровня</h2>
</section>
```

```css
.section-title {
    font-family: Arial, Helvetica, sans-serif;
    color: #ccc;
}
```

## Разделение кода на части

К CSS по БЭМ применяются основные принципы организации и хранения кода:
  * разделение кода на отдельные части — логика работы каждого блока, его опциональных элементов и модификаторов описывается в отдельных файлах;
  * CSS-файлы для каждого компонента хранятся в соответствии с [правилами организации файловой структуры](../filesystem/filesystem.ru.md) БЭМ-проекта.

**Пример**

Блок `button` в файловой структуре проекта:

```files
button/                      # Директория блока `button`
    _size
        button_size_s.css    # Реализация модификатора в технологии CSS
button.css                   # Реализация блока `button` в технологии CSS
```

Разделение кода на части и строгая организация файловой системы проекта позволяет:
* облегчить навигацию по проекту;
* повторно использовать и переносить компоненты;
* работать с уровнями переопределения и использовать сборку.

### Принцип единственной ответственности

Как и в объектно-ориентированном программировании принцип единственной ответственности (англ. Single responsibility principle) в CSS по БЭМ означает, что каждая CSS-реализация должна иметь одну ответственность. Все свойства селектора класса должны быть направлены исключительно на обеспечение этой ответственности.

**Пример**

Ответственность: размер кнопки

Верно:

```css
.button_size_s {
  font-size: 13px;
  line-height: 24px;
}
```

Неверно:

```css
.button_size_s  {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;
    background-color: white;   
    font-size: 13px;
    line-height: 24px;
}
```

Ответственность: цвет кнопки при наведении

Верно:

```css
.button_hovered {
    background: rgba(129,103,0,0.6);
}
```
Неверно:

```css
.button_hovered {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;
    background: rgba(129,103,0,0.6);
    font-size: 13px;
    line-height: 24px;
}
```

Фокусируясь на единичных ответственностях, мы можем придать нашему коду гораздо больше гибкости, а расширение функций компонентов становится более простым, если придерживаться принципа открытости/закрытости, который мы рассмотрим в следующем разделе.

### Принцип открытости/закрытости

Означает что любой элемент страницы должен быть открыт для модификации, но закрыт для изменения. Таким образом, разрабатывать новые CSS-реализации следует так, чтобы не пришлось менять уже существующие.

Вернемся к примеру с кнопкой.

**Пример**

CSS-реализация:

```css
.button {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;  
    font-size: 11px;
    line-height: 20px;
}

.button_size_s {
    font-size: 13px;
    line-height: 24px;
}
```

Мы расширили существующую функциональность класса `button` при помощи другого класса.

Нарушение принципа открытости/закрытости:

**Пример**

Изменение класса `button`:

```css
.button {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;
    font-size: 13px;
    line-height: 24px;
}
```

Модификация контентом:

```css
.button {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;  
    font-size: 11px;
    line-height: 20px;
}

.content .button {  
    font-size: 13px;
    line-height: 24px;
}
```

Кроме того, что мы изменили класс `button`, оформление кнопки стало зависеть от ее расположения. Изменения коснутся всех блоков `button` внутри блока `content`.

Помните: БЭМ-сущности открыты для расширения и закрыты для модификации.

### DRY

DRY, Don’t repeat yourself (Не повторяйся) — принцип разработки программного обеспечения, нацеленный на снижение повторений в коде.

Применительно к методологии БЭМ, его можно интерпретировать следующим образом:
каждая БЭМ-сущность должна иметь единственное, однозначное представление в рамках системы.

**Пример**

```css
.button {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;
}

.btn {
    font-family: Arial, Helvetica, sans-serif;
    position: relative;
}
```

Как видно из примера, в селекторе `btn` мы повторили существующую реализацию блока `button`.
Пытайтесь минимизировать случайные повторения.

### Композиция вместо наследования

Наследование представляет собой механизм, позволяющий описать новый CSS-класс на основе уже существующего (родительского, базового) класса. Класс-потомок может добавить собственные свойства, а также пользоваться родительскими.
Вместо наследования, новые CSS-реализации в БЭМ принято собирать из уже существующих, путем их объединения. Это сохраняет код несвязным и гибким.

**Пример**

```html
<button class="button button_theme_islands button_size_s">...</button>
```

## Работа с уровнями переопределения

Применение принципов БЭМ-методологии к CSS позволяет разделять представление блоков по разным уровням:
  * реализовывать новый внешний вид блока на другом уровне переопределения, сохраняя предыдущий, наследовать и дополнять его;
  * полностью перекрывать внешний вид блока (переопределять);
  * добавлять новые блоки с новым представлением, которого не было на предыдущих уровнях.

С помощью уровней переопределения можно создать универсальную CSS-библиотеку блоков и изменять ее на проектном уровне. Затем использовать сборку и включать в проект только необходимое представление блоков.

Пример уровней:

```files
common.blocks     # Общая библиотека блоков
desktop.blocks    # Блоки для ноутбуков и настольных компьютеров
touch.blocks      # Блоки для тачпадов
mobile.blocks     # Блоки для мобильных устройств

```

**Пример**

```css
.button_theme_islands {
    background-color: white;
}
```

Запись в стиле БЭМ позволяет:

* Полностью перекрывать внешний вид блока на другом уровне переопределения.

```css
.button_theme_islands {
    background-color: yellow;
}
```

* Добавлять или частично изменять внешний вид блока на другом уровне переопределения.

```css
.button_theme_islands {
    background-color: white;
    color: red;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
}
```

## Как перейти на CSS по БЭМ

Чтобы реализовать сразу все идеи БЭМ в вашем проекте, необходимо:
  * работать в единых терминах блоков, элементов и модификаторов во всех технологиях;
  * создавать независимые компоненты — блоки;
  * повторно использовать блоки, переносить их между проектами;
  * облегчить и ускорить разработку и отладку проекта за счет несвязанности компонентов и возможности разрабатывать поблочно;
  * изменять внешний вид блоков, элементов и модификаторов с помощью уровней переопределения;
  * включать в сборку только нужную CSS-реализацию блока;
  * облегчить навигацию по файловой структуре проекта.
