== Что такое БЭМ?
##БЭМ## расшифровывается как Блок-Элемент-Модификатор, смысл этих терминов раскрыт
ниже.

Один из самых распространённых примеров методологии в программировании – это ООП.
ООП – парадигма программирования, применимая во многих языках. Точно так же и методология
БЭМ – способ описания действительности в коде, набор паттернов и способ думать о
сущностях вне зависимости от того, на каком языке программирования это реализуется.

На основе этой методологии разработаны подходы к вёрстке и технические решения,
которые позволяют нам быстро создавать новые страницы и легко поддерживать уже
существующие.

=== Единая предметная область
Представьте обычный сайт. Например, такой, как на картинке.

%%html
<div style="text-align:center">
<img src="images/site.png"/>
</div>
%%

При разработке и развитии сайта удобно мысленно выделить «блоки», из которых сайт состоит.

Например, на этом макете есть ##Шапка##, ##Основной лайаут## и ##Подвал##. Шапка в свою
очередь состоит из ##Логотипа##, ##Поиска##, ##Блока авторизации## и ##Меню##. Основной
лайаут содержит ##Заголовок страницы## и ##Блок текста##.

%%html
<div style="text-align:center">
<img src="images/site-marked.png"/>
</div>
%%

Если у каждой части сайта есть название, этими терминами удобно пользоваться при общении
внутри команды.

Менеджер может попросить
 * увеличить ##Шапку##, или
 * Сделать ещё одну страницу, где в ##Шапке## нет ##Поиска##

Можно попросить JavaScript-разработчика
 * Сделать ##Блок авторизации## анимированным, и т.д.

Итак,

==== Блок
Мы называем блоком некоторую самостоятельную сущность, кирпичик проекта.
Блок может быть простым или составным, то есть содержать в себе другие блоки.

**Пример**\\
Блок поисковой формы\\

%%html
<div style="text-align:center">
<img src="images/search-block.png"/>
</div>
%%

==== Элемент
Элемент – это часть блока, отвечающая за отдельную функцию.
Он может находиться только в составе блока и не имеет смысла в отрыве от него.

**Пример**\\
Поле ввода и кнопка — элементы поискового блока

%%html
<div style="text-align:center">
<img src="images/search-block-marked.ru.png"/>
</div>
%%

=== Cредства описания страницы и шаблоны
Блоки и элементы – это обозначение содержания страницы. Помимо факта присутствия
конкретных блоков на странице, важно также их расположение.

Блоки (или элементы) могут идти друг за другом в определённом порядке.

Например, товары в интернет-магазине:

%%html
<div style="text-align:center">
<img src="images/goods-list.png"/>
</div>
%%

Или пункты меню:

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

Блоки могут быть вложены друг в друга.

Например, блок Шапка содержит другие блоки:

%%html
<div style="text-align:center">
<img src="images/head-marked.png"/>
</div>
%%

Чтобы быстро изменять содержание страницы, добавлять новые блоки, перемещать их друг
относительно друга, нужен способ описания страницы в виде текста. Для этого необходимо,
чтобы каждому блоку или элементу соответствовало ключевое слово.

Ключевое слово, обозначающее конкретный блок, называется ##именем блока##.

Например, ##menu## для меню или ##head## для шапки сайта.

Ключевое слово, обозначающее элемент, называется ##именем элемента##.

Например, каждый пункт меню – это элемент ##item## блока ##menu##.

Имя блока должно быть уникальным, из него однозначно следует, о каком блоке идёт речь.
Одинаковые имена могут быть только у одинаковых блоков. В этом случае мы говорим о том,
что один блок представлен на странице 2 (3, 4, …) раза.

Имя элемента должно быть уникальным только в пределах блока.
Элемент может повторяться в блоке несколько раз.

Например, пункты меню:

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

Такие ключевые слова нужно размещать в определённом порядке. Для этого подойдут форматы
данных с использованием вложенности. Например, XML или JSON:

%%hl xml
<b:page>
  <b:head>
    <b:menu>
      …
    </b:menu>
    <e:column>
      <b:logo/>
    </e:column>
    <e:column>
      <b:search>
        <e:input/>
        <e:button>Search</e:button>
      </b:search>
    </e:column>
    <e:column>
      <b:auth>
        …
      </b:auth>
    <e:column>
  </b:head>
</b:page>
%%

В данном примере пространства имён ##b## и ##e## использованы, чтобы отделять узлы блоков от узлов элементы.

То же самое в JSON:

%%hl js
{
  block: 'page',
  content: {
    block: 'head',
    content: [
      { block: 'menu', content: … },
      {
        elem: 'column',
        content: { block: 'logo' }
      },
      {
        elem: 'column',
        content: [
          {
            block: 'search',
            content: [
              { elem: 'input' },
              { elem: 'button', content: 'Search' }
            ]
          }
        ]
      },
      {
        elem: 'column',
        content: {
          block: 'auth', content: …
        }
      }
    ]
  }
}
%%

На примерах выше приведена объектная модель с вложенностью блоков и элементов в другие
блоки. Также в описании страницы присутствуют произвольные данные.

Такую структуру мы называем ##БЭМ-деревом## (по аналогии с DOM-деревом).

Конечный HTML для браузера получается из БЭМ-дерева страницы путём наложения шаблонов
(например, XSL-шаблоны или JavaScript).

Если разработчику нужно переместить блок в другое место на странице, это делается при
помощи изменения дерева. Конечный вид шаблоны сделают сами.

Вы можете использовать любой формат для описания БЭМ-дерева и любой шаблонизатор.

Мы ориентируемся на JSON как формат описания страницы.
Он превращается в HTML при помощи JavaScript-based шаблонизатора BEMHTML.

=== Независимость блоков
Во время разработки или поддержки долгоживущего проекта может возникнуть желание
переместить блок. Например, стоит задача

 * Поменять местами ##Логотип## и ##Блок авторизации##, или
 * Разместить ##Меню## под ##Поиском##

%%html
<div style="text-align: center">
<img src="images/head.png"/>
</div>
%%

%%html
<div style="text-align: center">
<img src="images/head-changed.png"/>
</div>
%%

Для того, чтобы легко выполнять эти просьбы, блоки должны быть ##независимыми##.

##Независимый## блок реализован так, чтобы его можно было вставить в любое место на странице.
В том числе и вставить в другой блок.

==== Независимый CSS
С точки зрения CSS для блока это означает, что

 * У блока (или элемента) должно быть уникальное «имя», на которое можно написать CSS
   правило. Например, соответствующий CSS-класс.
 * Не должно быть CSS-селекторов на теги (##.menu td##), они по определению контекстно-зависимые
 * Нужно избегать каскадные селекторы

===== Пример схемы именования независимых CSS-классов
Одна из возможных схем именования CSS-классов, удовлетворяющая требованиям, такая:

 * CSS-класс блока совпадает с ##именем блока##
%%hl xml
<ul class="menu">
  …
</ul>
%%
 * CSS-класс элемента — это ##имя блока## и ##имя элемента##, разделённые
 определённым символом (или символами)
%%hl xml
<ul class="menu">
  <li class="menu__item">…</li>
  <li class="menu__item">…</li>
</ul>
%%

Необходимость учитывать имя блока в CSS-классе для элемента нужна для минимизации каскада.

Так же важно использовать одинаковые разделители для облегчения написания инструментов
(описанных ниже) для программного доступа к элементам.

Мы используем дефис для разделения слов в длинных именах (например, ##block-name##) и два
подчёркивания для отделения имени блока от имени элемента (##block-name_~_element-name##).

Но вы можете использовать другую схему отделения слов в именах и отделения имени блока от
имени элемента.

Например:
  * ##block-name-~-element-name## или
  * ##blockName-elementName##

====Независимые шаблоны
С точки зрения шаблонного движка независимость блоков означает, что:

 * Блоки и элементы должны иметь описание во входных данных\\
   У блока (или элемента) должно быть уникальное «имя», чтобы при передаче данных шаблонному движку
   можно было сказать «здесь нужно разместить Меню».
 * Блок может быть легко помещён в любое место в БЭМ-дереве

===== Пример независимых шаблонов для блоков
Встречая во входных данных описание блока, шаблон должен однозначно преобразовывать его в
нужный HTML. Для этого у каждого блока должен быть свой шаблон.

Например, в XSL это может выглядеть так:

%%hl xml
<xsl:template match="b:menu">
  <ul class="menu">
    <xsl:apply-templates/>
  </ul>
</xsl:template>

<xsl:template match="b:menu/e:item">
  <li class="menu__item">
    <xsl:apply-templates/>
  </li>
<xsl:template>
%%

В своих собственных разработках мы постепенно отказываемся от XSL в пользу собственного
JavaScript-based шаблонного движка ((https://github.com/veged/xjst XJST)). Этот шаблонизатор вобрал в
себя всё то, что нам нравилось в XSL, но реализует это с производительностью JavaScript как на
сервере, так и на клиенте.

Мы пишем шаблоны для блоков на предметно-ориентированном языке (domain specific language) BEMHTML, в
основе которого лежит XJST.
((http://clubs.ya.ru/bem/replies.xml?item_no=992 Основные понятия шаблонизатора BEMHTML)) опубликованы в клубе БЭМ.

TODO: ссылка на BEMHTML reference

=== Повторяемость блоков
На сайте может появиться второй блок ##Меню##, например, в ##Подвале##. Или два блока ##Текст##,
разделённых рекламной вставкой.

Даже если блок проектировался как единственный, на странице в любой момент может появиться второй
такой же.

С точки зрения CSS это обозначает, что:
 * Для CSS-селекторов не используются селекторы с ID\\
   Вместо них удобно использовать классы

С точки зрения JavaScript это обозначает, что:
 * Блоки, которым требуется одинаковое поведение, могут быть однозначно определены: у них
одинаковый CSS-класс\\
   Используя селекторы класса, можно выбрать все одинаковые блоки на странице и задать им нужное
   динамическое поведение.

=== Модифицируемость блоков
Может возникнуть ситуация, в которой требуется не просто повторить блок, но и внести в него
незначительные изменения.

Например, стоит задача:
 * Сделать в подвале ещё одно меню, с //другим дизайном//.

%%html
<div style="text-align: center">
<img src="images/site-footer-menu.png"/>
</div>
%%

Чтобы не разрабатывать блок, минимально отличающийся от уже существующего,
нужно воспользоваться ##модификатором##.

##Модификатор## — это свойство блока или элемента, которое меняет внешний вид или поведение.

Модификатор имеет имя и значение. Одновременно может использоваться несколько разных модификаторов.

**Пример**\\
Модификатор блока задаёт ему цвет фона

%%html
<div style="text-align: center">
<img src="images/search-background.png"/>
</div>
%%

**Пример**\\
Модификатор элемента для текущего пункта меню изменяет его внешний вид

%%html
<div style="text-align: center">
<img src="images/menu-current-item.png"/>
</div>
%%

==== С точки зрения входных данных
В БЭМ-дереве модификаторы представлены как свойства той сущности, которая описывает блок или элемент.

Например, в XML это могут быть атрибуты соответствующего узла:

%%hl xml
<b:menu m:size="big" m:type="buttons">
  …
</b:menu>
%%

То же самое в формате JSON:

%%hl js
{
  block: 'menu',
  mods: [
   { size: 'big' },
   { type: 'buttons' }
  ]
}
%%

==== C точки зрения HTML/CSS
Модификатор представляется дополнительным CSS-классом блока или элемента.

%%hl xml
<ul class="menu menu_size_big menu_type_buttons">
  …
</ul>
%%

%%hl css
.menu_size_big {
  // CSS code to specify height
}
.menu_type_buttons .menu__item {
  // CSS code to change item's look
}
%%

Мы используем одно подчёркивание для отделение имени модификатора от имени блока и
ещё одно подчёркивание для отделения значения модификатора от его имени.

=== Модифицируемость элементов
Модифицируемость элементов реализуется по аналогии.

Обращаем ещё раз ваше внимание, что при написании CSS очень важно использовать одинаковые разделители имени
элемента от имени блока для работы с ними из инструментов и JavaScript-функций.

Например, модификатором можно обозначить текущий пункт меню:

%%hl xml
<b:menu>
  <e:item>Index<e:item>
  <e:item m:state="current">Products</e:item>
  <e:item>Contact<e:item>
</b:menu>
%%

%%hl js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'Index' },
    {
      elem: 'item',
      mods: { 'state' : 'current' },
      content: 'Products'
    },
    { elem: 'item', content: 'Contact' }
  ]
}
%%

%%hl css
.menu__item_state_current
{
  font-weight: bold;
}
%%

Что может быть представлено в HTML так:

%%hl xml
<ul class="menu">
  <li class="menu__item">Index</li>
  <li class="menu__item menu__item_state_current">Products</li>
  <li class="menu__item">Contact</li>
</ul>
%%

Или так, чтобы сделать классы меню независимым от деталей реализации его раскладки:

%%hl xml
<div class="menu">
  <ul class="menu__layout">
    <li class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </li>
  </ul>
</div>
%%

%%hl xml
<div class="menu">
  <table class="menu__layout">
  <tr>
    <td class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </td>
    <td class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </td>
    <td class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </td>
  </tr>
  </table>
</div>
%%

=== Предметная абстракция
Если над проектом работает много людей, им нужно договариваться о предметной области.
У всех блоков проекта должны быть однозначные имена, которые используются в коде.

Например, реализованный на сайте блок ##Облако тегов## всегда называется ##tags##, а каждый элемент
(метка) в нём - ##tag##. Это справедливо для любой технологии: CSS, JS, XSL, etc.

С точки зрения процесса разработки:
 * Все участники процесса оперируют одними терминами

С точки зрения CSS:
 * CSS блоков и элементов можно описывать на псевдоязыке, который затем компилируется в чистый
   CSS согласно принятой схеме именования.

%%hl css
  .menu {
    __layout {
      display: inline;
    }
    __layout-item {
      display: inline-block;
      …
    }
    __item {
      _state_current {
        font-weight: bold;
      }
    }
  }
%%

С точки зрения JavaScript:
 * Не нужно обращаться к DOM-узлам блоков и элементов по имени класса:

%%hl js
$('menu__item').click( … );
$('menu__item').addClass('menu__item_state_current');
$('menu').toggle('menu_size_big').toggle('menu_size_small');
%%

Схема именования CSS-классов для блоков и элементов может измениться. При использовании специальных
JavaScript-функций для обращения к блокам и работы с их модификаторами нужно будет внести изменения
только в эти функции

%%hl js
block('menu').elem('item').click( … );
block('menu').elem('item').setMod('state', 'current');
block('menu').toggleMod('size', 'big', 'small');
%%

Приведённый здесь код - абстрактный. В реальных разработках мы используем JavaScript-ядро блока
##i-bem## из библиотеки bem-bl: ((http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html))

=== Консистентность блока
На нашем сайте реализован блок ##Кнопка##, у которого есть динамическое поведение.

%%html
<div style="text-align: center">
<img src="images/button.png"/>
</div>
%%

При наведении курсора на этот блок он меняет свой внешний вид.

%%html
<div style="text-align: center">
<img src="images/button-cursor.png"/>
</div>
%%

Менеджер может попросить использовать такую же кнопку на другой странице.

Просто CSS-реализации блока недостаточно. Ведь в данном случае, чтобы полностью повторить блок,
нужно повторить и его поведение, описанное в JavaScript.

Таким образом, блок должен знать о себе всё. То есть реализация блока подразумевает описание его
внешнего вида и поведения во всех необходимых технологиях. Этот принцип мы называем ##мультилингвальность##.

##Мультилингвальность## - это описание блока на всех языках (технологиях), необходимых для его работы.

Если блок нужно представить на странице, у него должны быть реализованы технологии:
 * шаблоны (XSL, TT2, JavaScript, и т.д.), превращающие декларацию блока на странице в HTML-код
 * CSS, отвечающий за внешний вид блока
 * JavaScript-реализация блока, если у блока также есть динамическое поведение
 * Картинки, относящиеся к блоку
 * Документация к блоку

В список технологий входит всё, что относится к блоку.

=== Примеры из реальной жизни
Наиболее широко методологию БЭМ применяет в своих frontend разработках компания ((http://company.yandex.ru Яндекс)).

БЭМ-методология не требует применения определённого фреймворка. Также не обязательно
применять методологию для всех web-технологий, используемых для построения страницы (хотя
это был бы наиболее эффективный путь).

((http://www.yandex.ru/all Все сервисы Яндекса)) применяют методологию БЭМ в своём
CSS и JavaScript коде и XSL шаблонах страниц. Например,
 * ((http://maps.yandex.ru/?text=%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F%2C%20%D0%9C%D0%BE%D1%81%D0%BA%D0%B2%D0%B0&sll=37.609218%2C55.753559&ll=37.609218%2C55.753563&spn=2.570801%2C0.884460&z=9&l=map Яндекс.Карты))
 * ((http://images.yandex.ru/yandsearch?text=Yandex+office&rpt=image Яндекс.Картинки))
 * ((http://video.yandex.ru/#search?text=yac%202011 Яндекс.Видео))
 * ((http://auto.yandex.ru/ Яндекс.Авто))
 * ((http://www.yandex.com.tr/ Яндекс в Турции))

Некоторые сервисы вместо XSL шаблонов используют упомянутые в статье ##bemhtml## шаблоны:
 * ((http://yandex.ru/yandsearch?text=BEM+methodology+front-end&lr=213 Поиск Яндекса))\\
   ((http://yandex.com/yandsearch?text=%22What+is+BEM%3F%22+front-end&lr=213 Поиск на английском))
 * ((http://apps.yandex.ru/ Поиск по мобильным приложениям))\\
   Сайт для смартфонов

Другие российские порталы также используют БЭМ.

Например, сервисы ((http://mail.ru/ Mail.ru)) частично реализованы с применением БЭМ.
Это касается CSS реализации страниц, а также собственного C++ шаблонизатора компании.

Другие примеры:
 * ((http://beta.news.rambler.ru/ Рамблер.Новости))
 * ((http://hh.ru/ HeadHunter))
 * ((http://futurecolors.ru/tnkracing/ TNK Racing Team))

Сайты, разработанные на основе ((http://bem.github.com/bem-bl/index.ru.html библиотеки bem-bl)):
 * ((http://form.dev.eot.su/ Форма с JZ валидацией))
 * ((http://mishanga.pro/ Mikhail Troshev vCard))\\
   Код проекта на GitHub: ((https://github.com/mishanga/bem-vcard))

=== Читать дальше
  * Определения
  * ((../filesystem/ Организация файловой системы))
  * ((../history/ История создания))

