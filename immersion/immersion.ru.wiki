== Что такое БЭМ?
##БЭМ## расшифровывается как Блок-Элемент-Модификатор, смысл этих терминов раскрыт
ниже.

Один из самых распространённых примеров методологии в программировании – это ООП.
ООП – парадигма программирования, применимая во многих языках. Точно так же и методология
БЭМ – способ описания действительности в коде, набор паттернов и способ думать о
сущностях вне зависимости от того, на каком языке программирования это реализуется.

На основе этой методологии разработаны подходы к вёрстке и технические решения,
которые позволяют нам быстро создавать новые страницы и легко поддерживать уже
существующие.

=== Единая предметная область
Представьте обычный сайт. Например, такой, как на картинке.

%%html
<div style="text-align:center">
<img src="images/site.png"/>
</div>
%%

При разработке и развитии сайта удобно мысленно выделить «блоки», из которых сайт состоит.

Например, на этом макете есть ##Шапка##, ##Основной лайаут## и ##Подвал##. Шапка в свою
очередь состоит из ##Логотипа##, ##Поиска##, ##Блока авторизации## и ##Меню##. Основной
лайаут содержит ##Заголовок страницы## и ##Блок текста##.

%%html
<div style="text-align:center">
<img src="images/site-marked.png"/>
</div>
%%

Если у каждой части сайта есть название, этими терминами удобно пользоваться при общении
внутри команды.

Менеджер может попросить
 * увеличить ##Шапку##, или
 * Сделать ещё одну страницу, где в ##Шапке## нет ##Поиска##

Можно попросить JavaScript-разработчика
 * Сделать ##Блок авторизации## анимированным, и т.д.

Итак,

==== Блок
Мы называем блоком некоторую самостоятельную сущность, кирпичик проекта. Блок может быть
простым или составным, то есть содержать в себе другие блоки.

**Пример**\\
Блок поисковой формы\\

%%html
<div style="text-align:center">
<img src="images/search-block.png"/>
</div>
%%

==== Элемент
Элемент – это некоторая часть блока, отвечающая за отдельную функцию. Элемент может
находиться только в составе блока и не имеет смысла в отрыве от него.

**Пример**\\
Поле ввода и кнопка — элементы блока

%%html
<div style="text-align:center">
<img src="images/search-block-marked.ru.png"/>
</div>
%%

===Cредства описания страницы и шаблоны
Блоки и элементы – это обозначение содержания страницы. Помимо факта присутствия
конкретных блоков на странице, важно также их расположение.

Блоки (или элементы) могут идти друг за другом в определённом порядке:

Например, товары в интернет-магазине:

%%html
<div style="text-align:center">
<img src="images/goods-list.png"/>
</div>
%%

Или пункты меню:

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

Блоки могут быть вложены друг в друга:

Например, блок Шапка содержит другие блоки:

%%html
<div style="text-align:center">
<img src="images/head-marked.png"/>
</div>
%%


Чтобы быстро изменять содержание страницы, добавлять новые блоки, перемещать их друг
относительно друга, нужен способ описания страницы в виде текста. Для этого необходимо,
чтобы каждому блоку или элементу соответствовало ключевое слово.

Ключевое слово, обозначающее конкретный блок, называется ##именем блока##.

Например, ##menu## для меню или ##head## для шапки сайта.

Ключевое слово, обозначающее элемент, называется ##именем элемента##.

Например, каждый пункт меню – это элемент ##item## блока ##menu##.

Имя блока должно быть уникальным, из него однозначно следует, о каком блоке идёт речь.
Одинаковые имена могут быть только у одинаковых блоков. В этом случае мы говорим о том,
что один блок представлен на странице 2 (3, 4, ...) раза.

Имя элемента должно быть уникальным только в пределах блока. Элемент может повторяться
в блоке несколько раз. Например, пункты меню.

%%html
<div style="text-align:center">
<img src="images/menu-items.png"/>
</div>
%%

Такие ключевые слова нужно размещать в определённом порядке. Для этого подойдут форматы
данных с использованием вложенности. Например, XML или JSON:

%%hl xml
<b:page>
  <b:head>
    <b:menu>
      ...
    </b:menu>
    <e:column>
      <b:logo/>
    </e:column>
    <e:column>
      <b:search>
        <e:input/>
        <e:button>Search</e:button>
      </b:search>
    </e:column>
    <e:column>
      <b:auth>
        ...
      </b:auth>
    <e:column>
  </b:head>
</b:page>
%%

В данном примере пространства имён ##b## и ##e## использованы, чтобы отделять узлы про
блоки от узлов про элементы.

То же самое в JSON:

%%hl js
{
  block: 'page',
  content: {
    block: 'head',
    content: [
      { block: 'menu', content: ... },
      {
        elem: 'column',
        content: { block: 'logo' }
      },
      {
        elem: 'column',
        content: [
          {
            block: 'search',
            content: [
              { elem: 'input' },
              {
                elem: 'button',
                content: 'Search'
              }
            ]
          }
        ]
      },
      {
        elem: 'column',
        content: {
          block: 'auth',
          content: ...
        }
      }
    ]
  }
}
%%

На примерах выше приведена объектная модель с вложенностью блоков и элементов в другие
блоки. Также в описании страницы присутствуют произвольные данные.\\
Такую структуру мы называем ##БЭМ-деревом## (по аналогии с DOM-деревом).

Конечный HTML для браузера получается из БЭМ-дерева страницы путём наложения шаблонов
(например, XSL-шаблоны или JavaScript).

Если разработчику нужно переместить блок в другое место на странице, это делается при
помощи изменения дерева. Конечный вид шаблоны сделают сами.

В своих последних разработках мы ориентируемся на JSON как формат описания страницы. Он
превращается в HTML при помощи JavaScript-based шаблонизатора.\\
Ссылки на конкретные инструменты можно найти в конце статьи.

=== Независимость блоков

Во время разработки или поддержки долгоживущего проекта может возникнуть желание
переместить блок. Например, стоит задача

 * Поменять местами ##Логотип## и ##Блок авторизации##, или
 * Разместить ##Меню## под ##Поиском##

%%html
<div style="text-align: center">
<img src="images/head.png"/>
</div>
%%

%%html
<div style="text-align: center">
<img src="images/head-changed.png"/>
</div>
%%

Для того, чтобы легко выполнять эти просьбы, блоки должны быть ##независимыми##.

##Независимый## блок свёрстан так, чтобы его можно было вставить в любое место на странице.
В том числе и вставить в другой блок.

====Независимый CSS

С точки зрения CSS для блока это означает, что

 * У блока (или элемента) должно быть уникальное «имя», на которое можно написать CSS
   правило. Например, соответствующий CSS-класс.
 * Не должно быть CSS-селекторов на теги
 * Не нужно писать каскадные селекторы из нескольких блоков

=====Пример схемы именования независимых CSS-классов

Одна из возможных схем именования CSS-классов, удовлетворяющая требованиям, такая:

 * CSS-класс блока совпадает с ##именем блока##
%%hl xml
<ul class="menu">
  ...
</ul>
%%
 * CSS-класс элемента — это ##имя блока## и ##имя элемента##, разделённые
 определённым символом (или символами)
%%hl xml
<ul class="menu">
  <li class="menu__item">
    ...
  </li>
  <li class="menu__item">
    ...
  </li>
</ul>
%%
Необходимость учитывать имя блока в CSS-классе для элемента нужна для минимизации каскада.

Правила именования CSS-классов могут быть и другими. О том, какие мы используем соглашения об именовании,
можно прочесть ((http://bem.github.com/bem-bl/pages/naming/naming.ru.html здесь)).

====Независимые шаблоны

С точки зрения шаблонного движка независимость блоков означает, что:

 * Блоки и элементы должны иметь описание во входных данных\\
   У блока (или элемента) должно быть уникальное «имя», чтобы при передаче данных шаблонному движку
   можно было сказать «здесь нужно разместить Меню».
 * Блок может быть легко помещён в любое место в БЭМ-дереве

===== Пример независимых шаблонов для блоков
Встречая во входных данных описание блока, шаблон должен однозначно преобразовывать его в
нужный HTML. Для этого у каждого блока должен быть свой шаблон.

Например, в XSL это может выглядеть так:
%%hl xml
<xsl:template match="b:menu">
  <ul class="menu">
    <xsl:apply-templates/>
  </ul>
</xsl:template>

<xsl:template match="b:menu/e:item">
  <li class="menu__item">
    <xsl:apply-templates/>
  </li>
<xsl:template>
%%

В своих собственных разработках мы постепенно отказываемся от XSL в пользу собственного
JavaScript-based шаблонного движка ((https://github.com/veged/xjst XJST)). Этот шаблонизатор вобрал в
себя всё то, что нам нравилось в XSL, но реализует это с производительностью JavaScript как на
сервере, так и на клиенте.\\
Мы пишем шаблоны для блоков на предметно-ориентированном языке (domain specific language) BEMHTML, в
основе которого лежит XJST.
((http://clubs.ya.ru/bem/replies.xml?item_no=992 Основные понятия шаблонизатора BEMHTML)) опубликованы в клубе БЭМ.

=== Повторяемость блоков
На сайте может появиться второй блок ##Меню##, например, в ##Подвале##. Или два блока ##Текст##,
разделённых рекламной вставкой.\\
Даже если блок проектировался как единственный, на странице в любой момент может появиться второй
такой же.

С точки зрения CSS это обозначает, что:
 * Для CSS-селекторов не используются селекторы с ID\\
   Вместо них удобно использовать классы

С точки зрения JavaScript это обозначает, что:

 * Блоки, которым требуется одинаковое поведение, могут быть однозначно определены: у них
одинаковый CSS-класс\\
   Используя селекторы класса, можно выбрать все одинаковые блоки на странице и задать им нужное
   динамическое поведение.

===Модифицируемость блоков и элементов
Может возникнуть ситуация, в которой требуется не просто повторить блок, но и внести в него
незначительные изменения.\\
Например, стоит задача:
 * Сделать в подвале ещё одно меню, с //другим дизайном//.

%%html
<div style="text-align: center">
<img src="images/site-footer-menu.png"/>
</div>
%%

Чтобы не разрабатывать рядом блок, минимально отличающийся от уже существующего, нужно
воспользоваться ##модификатором##.

##Модификатор## — это свойство блока или элемента, которое немного меняет внешний вид или поведение.\\
Модификатор имеет имя и значение. Одновременно может использоваться несколько разных модификаторов.

**Пример**\\
Модификатор блока задаёт ему цвет фона

%%html
<div style="text-align: center">
<img src="images/search-background.png"/>
</div>
%%

**Пример**\\
Модификатор элемента для текущего пункта меню изменяет его внешний вид

%%html
<div style="text-align: center">
<img src="images/menu-current-item.png"/>
</div>
%%

С точки зрения входных данных:
 * В БЭМ-дереве модификаторы представлены как свойства той сущности, которая описывает блок или элемент

Например, в XML это могут быть атрибуты соответствующего узла:

%%hl xml
<b:menu m:size="big" m:type="buttons">
  ...
</b:menu>
%%

То же самое в формате JSON:

%%hl js
{
  block: 'menu',
  mods: [
   { size: 'big' },
   { type: 'buttons' }
  ]
}
%%

C точки зрения CSS:
 * Модификатор представляется дополнительным CSS-классом блока или элемента.

%%hl xml
<ul class="menu menu_size_big menu_type_buttons">
  ...
</ul>
%%

%%hl js
.menu_size_big {
  // CSS code to change height
}
.menu_type_buttons .menu__item {
  // CSS code to change item's view
}
%%

Модифицируемость элементов реализуется по аналогии.

Например, модификатором можно обозначить текущий пункт меню:

%%hl xml
<b:menu>
  <e:item>Index<e:item>
  <e:item m:state="current">Products</e:item>
  <e:item>Contact<e:item>
</b:menu>
%%

%%hl js
{
  block: 'menu',
  content: [
    { elem: 'item', content: 'Index' },
    {
      elem: 'item',
      mods: { 'state' : 'current' },
      content: 'Products'
    },
    { elem: 'item', content: 'Contact' }
  ]
}
%%

%%hl xml
<div class="menu">
  <ul class="menu__layout">
    <li class="menu__layout-unit">
      <div class="menu__item">Index</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item menu__item_state_current">Products</div>
    </li>
    <li class="menu__layout-unit">
      <div class="menu__item">Contact</div>
    </li>
  </ul>
</div>
%%

%%hl js
.menu__item_state_current {
  font-weight: bold;
}
%%

=== Предметная абстракция
Если над проектом работает много людей, им нужно договариваться о предметной области. У всех блоков
проекта должны быть однозначные имена, которые используются в коде.

Например, реализованный на сайте блок ##Облако тегов## всегда называется ##tags##, а каждый элемент
(метка) в нём - ##tag##. Это справедливо для любой технологии: CSS, JS, XSL, etc.

С точки зрения процесса разработки:
 * Все участники процесса оперируют одними терминами

С точки зрения CSS:
 * CSS блоков и элементов можно описывать на псевдоязыке, который затем компилируется в чистый
   CSS согласно принятой схеме именования.

%%hl js
  .menu {
    __layout {
      display: inline;
    }
    __layout-item {
      display: inline-block;
      ...
    }
    __item {
      _state_current {
        font-weight: bold;
      }
    }
  }
%%

С точки зрения JavaScript:
 * Не нужно обращаться к DOM-узлам блоков и элементов по имени класса

%%hl js
$('menu__item').click( ... );
$('menu__item').addClass('menu__item_state_current');
$('menu').toggle('menu_size_big').toggle('menu_size_small');
%%

Схема именования CSS-классов для блоков и элементов может измениться. При использовании специальных
JavaScript-функций для обращения к блокам и работы с их модификаторами нужно будет внести изменения
только в эти функции

%%hl js
Block('menu').elem('item').click( ... );
Block('menu').elem('item').setMod('state', 'current');
Block('menu').toggleMod('size', 'big', 'small');
%%

Приведённый здесь код - абстрактный. В реальных разработках мы используем JavaScript-ядро блока
##i-bem## из библиотеки bem-bl: ((http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html))

=== Консистентность блока
На нашем сайте реализован блок Кнопка, у которого есть динамическое поведение.

%%html
<div style="text-align: center">
<img src="images/button.png"/>
</div>
%%

При наведении курсора на этот блок он меняет свой внешний вид.

%%html
<div style="text-align: center">
<img src="images/button-cursor.png"/>
</div>
%%

Менеджер может попросить:
 * Использовать такую же кнопку на другой странице

Просто CSS-реализации блока недостаточно. Ведь в данном случае, чтобы полностью повторить блок, нужно
повторить и его поведение, описанное в JavaScript.

Таким образом, блок должен знать о себе всё. То есть реализация блока подразумевает описание его
внешнего вида и поведения во всех необходимых технологиях. Этот принцип мы называем ##мультилингвальность##.

##Мультилингвальность## - это описание блока на всех языках (технологиях), необходимых для его работы.

Если блок нужно представить на странице, у него должны быть реализованы технологии:
 * шаблоны (XSL, TT2, JavaScript, и т.д.), превращающие декларацию блока на странице в HTML-код
 * CSS, отвечающий за внешний вид блока

Когда у блока также есть динамическое поведение, к этому списку добавляются:
 * JavaScript-реализация блока

В список технологий входит всё, что относится к блоку, в том числе и:
 * Картинки блока

=== Представление блоков на файловой системе
==== Однозначное положение кода
===== Именование файлов
Если проект
 * живёт долго и постоянно обрастает новыми сущностями

Если команда разработки
 * состоит из нескольких специалистов
 * растёт и изменяется (появляются новые люди)

нужен способ быстро определять, где может находиться код блока.

Код блока легко искать, если он расположен в файлах, одноимённых ключевому слову блока:

%%html
<pre>
menu.xsl
menu.js
menu.css
</pre>
%%

===== Файловая независимость блока
Может возникнуть задача
 * использовать несколько блоков предыдущего проекта на новом проекте

Чтобы легко делать это, реализацию блока (во всех технологиях) нужно уметь доставлять в
другое место. Это может быть сделано при помощи копирования файлов или частичным чекаутом
репозитория проекта-донора. И в том, и в другом случае удобно, чтобы все файлы, относящиеся
к блоку, были объединены в одну папку:

%%html
<pre>
menu/
  menu.xsl
  menu.js
  menu.css
</pre>
%%

===== Файловая структура блока
В процессе работы над проектом может возникнуть необходимость изменить какой-нибудь блок.

Менеджер может попросить:
 *  Изменить цвет ##активному пункту Меню##, или
 *  Сделать ##Меню## реагирующим на наведение курсора

Один разработчик может попросить другого:
 *  Помочь с вёрсткой ##Поисковой формы## под IE

Чтобы можно было сразу понять, где лежит код, о котором идёт речь, нужно соблюдать в
разработке следующие требования:
 * Код блока размещён в отдельной директории
   * Имя директории совпадает с именем блока
   * Техническая реализация блока размещена в файлах в директории блока
 * Элементу соответствует поддиректория в директории блока
   * Имя директории совпадает с именем элемента
   * Техническая реализация элемента располагается в файлах в этой директории
 * Модификатору соответствует поддиректория в директории блока
   * Имя директории соответствует имени модификатора
   * Техническая реализация модификатора размещается в файлах в этой директории
   * Названия файлов содержат как имя, так и значение модификатора

**Пример**\\
Файловая структура блока Меню

%%html
<pre>
menu/
  __item/
    _state/
      menu__item_state_current.css
      menu__item_state_current.xsl
    menu__item.css
    menu__item.xsl
  menu.css
  menu.js
  menu.xsl
</pre>
%%

Поддерживать такую файловую структуру вручную неудобно. Для работы с файлами мы используем
((https://github.com/bem/bem-tools БЭМ-инструменты)). Это набор утилит, позволяющий создавать
файлы по определённым шаблонам и с определённой схемой расположения на файловой системе.

===== Группировка блоков в папки
На большом портале необходимо реализовывать одни и те же блоки на разных проектах.

Может возникнуть задача:
 * Реализовать одинаковый Подвал ##на всех проектах Портала##, или
 * Сделать  ##новый проект##, используя блоки уже существующего

Разработка сайтов один за другим в web-студии часто подразумевает использование типовых решений для типовых страниц.

Менеджер может попросить:
 * Сделать Страницу заказа товара с формой ##как на позапрошлом проекте##

Выполнять эти задачи нужно без копирования блоков из проекта в проект. Должна быть возможность
подключить блоки одного проекта к другому. Для этого блоки нужно объединять в одну директорию.

Мы называем такую директорию ##blocks##.

**Пример**

%%html
<pre>
blocks/
  foot/
  head/
  menu/
  page/
  search/
</pre>
%%

Такую папку можно подключить к новому проекту прямо из репозитория. Так, код блока будет храниться
только в одном месте. Если нужно исправить ошибку или внести другие изменения, это нужно будет сделать только там.

==== Уровни переопределения
Если группа блоков одного проекта (объединённая в папку) подключена к другому проекту напрямую
(при помощи частичного чекаута или svn:externals), то любое закоммиченное изменение в таких блоках
повлияет на оба проекта.

При разработке одного сайта на основе существующего может потребоваться:
 * Увеличить шрифт в Шапке на всём сайте (не затрагивая предыдущий сайт),
 * Добавить анимацию для раскрытия всех выпадающих меню.

То есть необходима возможность переопределять (или доопределять) блоки в разных технологиях только
для определённого сайта или только для определённых страниц. Это возможно благодаря ##уровням переопределения##.

##Уровень переопределения## — это набор реализаций блоков, сгруппированных в одну директорию.

%%html
<div style="text-align:center;">
<img src="images/levels-schema.png"/>
</div>
%%

Реализация любого блока библиотеки может быть расширена (или переопределена) на уровне проекта.

%%html
<div style="text-align:center;">
<img src="images/block-levels.png"/>
</div>
%%

С точки зрения сборки страниц:
 * При сборке каждой страницы можно указать список уровней (директорий), блоки которых будут
   представлены на странице. Например,\\
   ##build-page -l blocks-common -l blocks-my my-page.html##

С точки зрения файловой структуры:
 * Проект можно содержать любое количество реализаций блоков. Но на страницу попадут только те,
   которые явно указаны к применению для сборки этой страницы. Возможно делать разные наборы
   уровней переопределения для разных разделов сайтов.

С точки зрения JavaScript
 * Необходима возможность декларативного описания динамического поведения элементов на странице.
   Конечное поведение должно собираться с разных уровней переопределения. Например,

%%hl js
/* blocks-common/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    ...
  }
});

/* blocks-my/dropdown/dropdown.js */
Block('dropdown', {
  init: function() {
    this.__base();
    ...
  }
});
%%

С точки зрения шаблонного движка
* Для того, чтобы можно было не только переопределять, но и "доопределять" шаблон, нужна
   возможность вызвать предыдущую реализацию шаблона.\\
   Например, в случае xsl:

%%hl xml
<xsl:template match="b:head">
  <div> <!-- Node for extra design -->
    <xsl:apply-imports/>
  </div>
</xsl:template>
%%

С точки зрения архитектуры проекта

 * При разработке портала из нескольких сайтов можно выделить общую библиотеку блоков, которая станет
   одним из уровней переопределения для всех сайтов портала. Блоки конкретного сайта — объединить в
   другой уровень переопределения.
 * В одном и том же репозитории может храниться реализация сайта для десктопных и мобильных браузеров.\\
   В таком проекте есть уровень переопределения для общей реализации блоков, для мобильной и для десктопной.
   Различные комбинации уровней дают желаемую реализацию блоков на конкретных страницах.

Примером реализации нескольких уровней переопределения в одном репозитории может служить
((https://github.com/bem/bem-bl Open Source библиотека блоков bem-bl)).

=== Сборка страниц
Работа со страницей в терминах блоков подразумевает ##предметную абстракцию##. Эта предметная абстракция
обязательна только на уровне взаимодействия человека с кодом. Когда код попадает в браузер, наличие
предметной абстракции не обязательно, важно лишь сохранить требуемый внешний вид и поведение блоков на странице.

Таким образом, ##код для людей## и ##код для браузеров## — не одно и то же:
 * Человек пишет код блоков, браузер получает код целой страницы

Для того, чтобы превратить "код для людей" в "код для браузеров", существует понятие ##сборки страниц##.

##Сборка страницы## — это формирование кода страницы в различных технологиях
(HTML, CSS, JavaScript) на основе декларативного описания страницы (XML, JSON)
путём применения реализаций описанных блоков.

С точки зрения CSS

 * Файлы всех блоков собираются в один файл страницы\\
   Несмотря на то, что CSS для каждого блока, элемента и модификатора реализован в отдельном файле,
   для работы страницы нет необходимости подключать эти файлы as is. Всю необходимую CSS-реализацию
   страницы можно собрать в один файл. К тому же это решает проблемы: ограниченного количества импортов
   в IE, количества HTTP-запросов к серверу. Объединение всех CSS в один файл мы делаем при помощи
   утилиты ((https://github.com/veged/borschik borschik)).
 * Браузер получает минимизированный код\\
   В процессе сборки можно минимизировать и оптимизировать CSS-код. Например, при помощи утилиты
   ((https://github.com/afelix/csso CSSO))
 * Каждый браузер получает CSS, написанный специально для него\\
   Есть возможность разделять CSS-реализации для разных браузеров и поставлять в каждый конкретный
   браузер только тот CSS, который нужен ему. Для этого можно использовать ((https://github.com/afelix/setochka Сеточку, прототип))

С точки зрения JavaScript
 * Много файлов для блоков, один файл для страницы\\
   Так же, как и в случае CSS, JavaScript-реализация всех необходимых блоков может быть объединена в один файл.

С точки зрения шаблонных движков
 * Работают только нужные шаблоны\\
   Конечный набор шаблонов, используемых для вывода HTML страницы в результате сборки содержит только
   шаблоны нужных блоков. Благодаря этому увеличивается производительность шаблонов и  уменьшается
   вероятность возникновения побочных эффектов.

С точки зрения процесса разработки
 * Роботы на службе у человека (не наоборот)\\
   Разработчик пишет код так, как ему удобно. О производительности заботятся роботы, которые в процессе
   сборки превращают код в оптимизированный (и, возможно, нечитаемый).

С точки зрения организации труда
 * Разделение труда\\
   Существуют одни разработчики, создающие блоки, и существуют другие разработчики, занимающиеся
   оптимизацией конечного продукта.

Для сборки файлов страниц используются ((https://github.com/bem/bem-tools БЭМ-инструменты)).

==== Автоматизация сборки

Использование ((https://github.com/bem/bem-tools БЭМ-инструментов)) подразумевает выполнение
нескольких операций для каждой страницы. В результате этих операций на основе bemjson описания
страницы генерируются CSS и JavaScript файлы страницы, шаблоны страницы и (в случае статической разработки)
- HTML страницы.

Чтобы не выполнять эти команды вручную, для проекта на БЭМ методе обычно пишут ((http://www.gnu.org/software/make/manual/make.html GNUmakefile))
с инструкциями по сборке страниц.\\
Пример такого файла можено найти в тестовом проекте ((https://github.com/bem/bem-bl-test/blob/master/GNUmakefile bem-bl-test)).

Однако, использование GNU make имеет ряд проблем:

 * нужно его запускать руками каждый раз после редактирования;
 * из-за того, что при каждом запуске gmake заново перечитывает информацию с диска, компиляция не очень быстрая;
 * т.к. по нашей методологии наличие/отсутсвие файла на диске имеет значение, мы не можем выразить
зависимости с помощью отношений цель-пререквизит.

Мы хотим сделать нечто, что заменит нам GNU make в процессе сборки страниц. Это
будет одновременно и сервер для разработки и способ статически собрать файлы для продакшена.
##bem server## будет запускаться в корне проекта и отвечать по http на-лету собираемыми файлами
(т.е. не нужно запускать gmake вручную после каждого изменения).\\
Кроме того, он сможет с помощью ((http://nodemanual.org/latest/nodejs_ref_guide/fs.FSWatcher.html fs.FSWatcher))
следить за изменением, появлением и удалением файлов, что позволит эффективнее кешировать
результаты сборок до момента, когда они потеряют актуальность.

##bem server## -- это одна из комманд ((https://github.com/bem/bem-tools bem-tools)), в нынешней версии
она умеет запускать HTTP-сервер, накладывать ##bemhtml##-шаблоны на ##bemjson##-описание страницы и
инлайнить import`ы в CSS-файлах при помощи ((https://github.com/veged/borschik утилиты borschik)).\\
Подробности можно прочесть в ((http://clubs.ya.ru/bem/replies.xml?item_no=1261 анонс на Я.ру)).

=== Примеры из реальной жизни

Наиболее широко методологию БЭМ применяет в своих frontend
разработках компания ((http://yandex.ru Яндекс)).

БЭМ-методология не требует применения определённого фреймворка. Также не обязательно
применять методологию для всех web-технологий, используемых для построения страницы (хотя
это был бы наиболее эффективный путь).

((http://www.yandex.ru/all Все сервисы Яндекса)) применяют методологию БЭМ в своём
CSS и JavaScript коде и XSL шаблонах страниц. Например,
 * ((http://maps.yandex.ru/?text=%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F%2C%20%D0%9C%D0%BE%D1%81%D0%BA%D0%B2%D0%B0&sll=37.609218%2C55.753559&ll=37.609218%2C55.753563&spn=2.570801%2C0.884460&z=9&l=map Яндекс.Карты))
 * ((http://images.yandex.ru/yandsearch?text=Yandex+office&rpt=image Яндекс.Картинки))
 * ((http://video.yandex.ru/#search?text=yac%202011 Яндекс.Видео))
 * ((http://auto.yandex.ru/ Яндекс.Авто))
 * ((http://www.yandex.com.tr/ Яндекс в Турции))

Некоторые сервисы вместо XSL шаблонов используют упомянутые в статье ##bemhtml## шаблоны:
 * ((http://yandex.ru/yandsearch?text=BEM+methodology+front-end&lr=213 Поиск Яндекса))\\
   ((http://yandex.com/yandsearch?text=%22What+is+BEM%3F%22+front-end&lr=213 Поиск на английском))
 * ((http://apps.yandex.ru/ Поиск по мобильным приложениям))\\
   Сайт для смартфонов

Другие российские порталы также используют БЭМ.

Например, сервисы ((http://mail.ru/ Mail.ru)) частично реализованы с применением БЭМ.
Это касается CSS реализации страниц, а также собственного C++ шаблонизатора компании.

Другие примеры:
 * ((http://beta.news.rambler.ru/ Рамблер.Новости))
 * ((http://hh.ru/ HeadHunter))
 * ((http://futurecolors.ru/tnkracing/ TNK Racing Team))

Сайты, разработанные на основе ((http://bem.github.com/bem-bl/index.ru.html библиотеки bem-bl)):
 * ((http://mishanga.pro/ Mikhail Troshev vCard))\\
   Код проекта на GitHub: ((https://github.com/mishanga/bem-vcard))
 * ((http://form.dev.eot.su/ Форма с JZ валидацией))

=== Связанные ссылки
==== Библиотеки
 * ((http://bem.github.com/bem-bl/index.ru.html Библиотека блоков, разрабатываемых по БЭМ-методу))
==== Инструменты
 * ((https://github.com/bem/bem-tools Инструменты для работы с файлами по БЭМ-методу))
 * ((https://github.com/veged/borschik Borschik))\\
   Утилита для сборки статических файлов web-проектов в один.
 * ((https://github.com/afelix/setochka Сеточка, прототип))\\
   Инструмент для выделения CSS-свойств исходного CSS в отдельные файлы. Также может
   использоваться для удаления этих свойств без записи.
 * ((https://github.com/afelix/csso CSSO))\\
   Утилита, оптимизирующая CSS-код с учётом его структуры.
==== Дополнительная информация
 * ((http://clubs.ya.ru/bem/posts.xml?tag=64664080 Видео выступлений и мастер-классов))
 * ((http://clubs.ya.ru/bem/ Клуб БЭМ на Я.ру))
