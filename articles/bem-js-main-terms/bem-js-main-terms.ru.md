# JavaScript по БЭМ: основные понятия

В стеке БЭМ-технологий есть [блок i-bem](http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html)
библиотеки `bem-bl`. Его JavaScript-реализация использует предметную область БЭМ
и позволяет насладиться всеми преимуществами разработки по принципам БЭМ не
только программируя внешний вид компонент, но и их поведение.

## Зачем нужен ещё один фреймворк?
В принципе, все существующие JavaSript-библиотеки можно условно разделить между
собой на несколько категорий:

 * отвечающие за нормализацию API браузеров<br/>
   Например, jQuery или base2 (когда-то очень давно, еще на заре формирования
   стеков фреймворков, она была очень популярной);
 * предоставляющие какие-то готовые наборы виджетов;
 * сложные библиотеки, которые предназначены для создания так называемых Rich UI интерфейсов;
 * «монстры»<br/>
 Полноценные библиотеки для написания сложных веб-приложений.

Разделение достаточно условное, и скорее всего многие библиотеки можно
одновременно отнести к нескольким категориям. Но важно одно: у них у всех одна
цель — помогать нам решать наши задачи.

Разработчики старой школы ещё помнят времена, когда не было даже jQuery и все
приходилось делать самостоятельно. У каждого на проекте был свой `common.js`,
который включал в себя набор вспомогательных функций. Всё это сначала
копипастили из проекта в проект, а потом их выносили в свою маленькую JavaScript
библиотеку.<br/>
Так, эволюционно появлялись JavaScript-фреймворки.

То же самое произошло и в БЭМ. Сначала понятие блоков (интерфейсных модулей), их
элементов и модификаторов существовало только для CSS. Затем разработчики
захотели работать с такой же структорой в JavaScript, и вдобавок использовать 4е
ключевое понятие — `уровни переопределения` — чтобы дополнять и расширять
поведение блоков от проекта к проекту.<br/>
Таким образом, появилась JavaScript реализация блока-хелпера
[i-bem.js](https://github.com/bem/bem-bl/tree/master/blocks-common/i-bem),
который хранится на GitHub. Это и есть фреймворк (или блок-ядро) для того, чтобы
писать JavaScript в БЭМ-терминах.

## Ассоциация с HTML-кодом
Как и любой JavaScript-компонент, код, написанный под `i-bem.js` должен быть
проассоциирован с HTML-фрагментом, который он намерен превратить в
функционирующую часть интерфейса. Здесь для этого достаточно добавить блоку
CSS-класс `i-bem` и указать в атрибуте onclick параметры блока.

```js
<div
    class="myblock i-bem"
    onclick="return {
        myblock: { }}">

    <span class="myblock__item"></span>

</div>
```

О том, почему `onclick`, можно узнать из доклада Сергея Бережного «[Разные способы создания клиентских компонентов](https://events.yandex.ru/events/yasubbotnik/msk-jul-2012/talks/302/)»,
прозвучавшего на
[Я.Субботнике](https://events.yandex.ru/events/yasubbotnik/) в июле 2012.

Инициализация блоков на странице в общем случае запускается по `domReady`.
Благодаря возможности считать параметры из onclick и получить нативный
JavaScript-объект не нужны `id` компонент или парсинг CSS-классов: все блоки,
помеченные классом `i-bem` превратятся в соответствующие их параметрам
компоненты.

## Декларация поведения
А в JavaScript-файле блока (`myblock.js`) описывается его поведение.

С точки зрения объектной модели все одинаковые блоки образуют класс. При
этом каждое появление блока на странице рождает экземпляр этого класса.

Для описания поведения используется метод `decl`, принимающий 3 параметра:

 1. Блок, о котором пойдёт речь
 2. Собственные свойства экземпляра блока
 3. Статические свойства класса, к которому принадлежит блок

```js
BEM.DOM.decl('myblock', {

    /\* собственные свойства экземпляра \*/

}, {

    /\* статические свойства \*/

});
```

Внутри JavaScript ссылку на экзепляр всегда можно получить по ключевому слову
`this` и использовать его зарезервированные поля `__self` и `__base`.

 * `this.__self`<br/>
 Ссылается на статические методы класса, к которому принадлежит экземляр
 * `this.__base`<br/>
Делает super call, то есть вызвает базовую реализацию метода.

Последнее позволяет использовать уровни переопределения. При расширении
функциональности уже существующего блока, разработчик всегда имеет доступ к
поведению, определённому предыдущим уровнем. То есть методы можно не только
полностью перезаписывать, но и «обрамлять» дополнительным поведением.

```js
BEM.DOM.decl('myblock', {

    method: function() {

        this.__base();
        this.doMore();

    }

});```

Кроме наследования по уровням переопределения, есть ещё возможность явно
отнаследовать один блок от другого. Поэтому возможность "наследования" от уровня
к уровню лучше воспринимать как мёрдж реализаций.

## Селекторы блоков
Для поиска других блоков можно воспользоваться одним из `find*` методов, в
зависимости от того, где находится желаемый блок относительно текущего:

```js
// поиск внутри контекста
this.findBlockInside([elem], block)

// поиск снаружи контекста
this.findBlockOutside([elem], block)

// поиск на DOM-узле текущего блока
this.findBlockOn([elem], block)
```

Все эти методы возращают JavaScript-объект, экземпляр найденного блока.

Похожим образом можно найти и коллекции блоков:

```js
// поиск внутри контекста
this.findBlocksInside([elem], block)

// поиск снаружи контекста
this.findBlocksOutside([elem], block)

// поиск на BEM-узле текущего блока
this.findBlocksOn([elem], block)
```

## Элементы
Аналогично, есть методы для доступа к элементам блока: `elem` и `findElem`.
Отличие в том, что метод `elem` кеширует свой результат при первом обращении. То
есть можно не сохранять вызов в переменную, чтобы сэкономить на поиске — всё уже
сделано в реализации этого метода.

```js
//кеширующий селектор
this.elem(name,
    [modName], [modVal])

//некеширующий
this.findElem([ctx], name,
    [modName], [modVal])
```

## Модификаторы
Модификаторы в JavaScript служат для выражения состояния блока или элемента.

Методы работы с модификаторами одинаковы и для блоков, и для элементов. Но
первый (опциональный) параметр показывает, о чём идёт речь.

```js
// значение модификатора блока
this.getMod(modName)

// значение модификатора элемента
this.getMod(elem, modName)

// проверка модификатора
this.hasMod([elem], modName, modVal)

// установка модификатора
this.setMod([elem], modName, modVal)

// удаление модификатора
this.delMod([elem], modName)

// переключение значений модификатора
this.toggleMod([elem], modName,
    modVal1, modVal2, [condition])
```

Сами модификаторы описываются как состояние блока. То есть, экземпляр блока
знает о том, как ему нужно среагировать на установку модификатора.<br/>
Для такого описания используется поле `onSetMod` из собственных свойств блока.

```js
BEM.DOM.decl('myblock', {
    onSetMod : {
        'mod1' : {

            // установка модификатора mod1 в val1
            'val1' : function(mod, val, oldVal) {
            }

        },

        // установка модификатора`mod2` в любое значение
        'mod2' : function(mod, val, oldVal) {
        }
    }
});
```

Похожая декларация есть и для модификаторов элементов:

```js
BEM.DOM.decl('myblock', {
    // …

    onElemSetMod : {

        // структура, аналогичная блоку
        'elem' : {
            'mod1' : {

                // дополнительный параметр `elem`
                'val1' : function(elem, mod, val, oldVal) {
                }

            }
        }
    }

});
```

## События
События играют ключевую роль в JavaScript. Поэтому и при реализации блока
`i-bem` их не обошли вниманием. Специальные методы позволяют работать с
событиями как на DOM-узлах, соответствующих блокам, так и на BEM-объектах
(JavaScript-объектах, представляющих экземляры блоков).

```js
// DOM-события
this
    .bindTo([elem], event, fn)
    .unbindFrom([elem], event)

// BEM-события
this
    .on(event, [data], fn, [ctx])
    .un(event, [data], fn, [ctx])
    .trigger(event, [data])
```

DOM-события не нуждаются в пояснении — это то, что происходит в результате
действий пользователя: клик мышкой, работа с клавиатурой, прокрутка и т.д.

BEM-события — это кастомные события, нужные для возможности организовать API
блоков.

## Инициализация
Работа блока начинается с его инициализации. В этот момент у блока появляется
модификатор `js_inited`.

Аналогично другим модификаторам, на его установку можно реагировать исполнением
задекларированного кода. То есть, есть возможность написать "конструктор".

```js
onSetMod : {

    'js' : {

        'inited' : function(){

            // "конструктор" блока

        }
    }
}
```

Кроме описанного, блок `i-bem` предоставляет для других блоков возможности
отложенной (ленивой) инициализации, позволяет писать блоки без
DOM-представления, использует идею делигирования событий и многое другое.<br/>
Об этом можно прочесть на [странице блока i-bem](http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html).

Статья подготовлена по материалам выступления [Владимира Варанкина](https://github.com/narqo) «[БЭМ и JavaScript: Зачем мы написали JS-фреймворк?](https://events.yandex.ru/events/yasubbotnik/msk-sep-2012/talks/323/)» на Я.Субботнике в Москве 8 сентября 2012.
