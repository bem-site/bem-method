# Часто задаваемые вопросы

Возникли вопросы по БЭМ? Мы поможем быстро найти ответы.

## Почему БЭМ?

* [В чем отличие БЭМ от OOCSS, AMCSS, SMACSS, SUITCSS?](#в-чем-отличие-бэм-от-oocss-amcss-smacss-suitcss)
* [В чем разница между БЭМ и Web Components?](#в-чем-разница-между-бэм-и-web-components)
* [В чем разница между БЭМ и Bootstrap?](#в-чем-разница-между-бэм-и-bootstrap)
* [Полезен ли БЭМ в маленьких проектах?](#полезен-ли-бэм-в-маленьких-проектах)

## Блоки и элементы

* [Когда создавать блок, когда — элемент?](#когда-создавать-блок-когда--элемент)
* [Как изменить внешний вид блока?](#как-изменить-внешний-вид-блока)
* [Зачем в именах модификаторов и элементов указывать имя блока?](#зачем-в-именах-модификаторов-и-элементов-указывать-имя-блока)
* [Зачем создавать отдельные директории и файлы для каждого блока и технологии?](#зачем-создавать-отдельные-директории-и-файлы-для-каждого-блока-и-технологии)
* [Наследуют ли элементы блока его CSS-свойства?](#наследуют-ли-элементы-блока-его-css-свойства)
* [Почему не стоит создавать блоки-обертки?](#почему-не-стоит-создавать-блоки-обертки)
* [Почему не стоит создавать элементы элементов (block\__elem1\__elem2)?](#почему-не-стоит-создавать-элементы-элементов-block__elem1__elem2)

## Модификаторы и миксы

* [Когда создавать модификатор, когда — микс?](#когда-создавать-модификатор-когда--микс)
* [Когда создавать булевый модификатор, когда — модификатор «ключ-значение»?](#когда-создавать-булевый-модификатор-когда--модификатор-ключ-значение)
* [Как выбрать имя модификатора?](#как-выбрать-имя-модификатора)
* [Как сделать глобальные модификаторы для блоков?](#как-сделать-глобальные-модификаторы-для-блоков)
* [Почему нельзя писать имя модификатора блока в имени элемента (block_mod__elem)?](#почему-нельзя-писать-имя-модификатора-блока-в-имени-элемента-block_mod__elem)

## CSS

* [Как адаптировать сайт к различным устройствам?](#как-адаптировать-сайт-к-различным-устройствам)
* [Можно ли совмещать теги и классы в селекторе?](#можно-ли-совмещать-теги-и-классы-в-селекторе)
* [Можно ли использовать вложенные селекторы?](#можно-ли-использовать-вложенные-селекторы)
* [Можно ли использовать комбинированные селекторы?](#можно-ли-использовать-комбинированные-селекторы)
* [Можно ли использовать селекторы по пользовательским тегам?](#можно-ли-использовать-селекторы-по-пользовательским-тегам)
* [Почему не стоит делать общий сброс стилей (reset)?](#почему-не-стоит-делать-общий-сброс-стилей-reset)
* [Почему не стоит писать block_mod вместо block block_mod?](#почему-не-стоит-писать-block_mod-вместо-block-block_mod)
* [В каких случаях следует создавать вспомогательные блоки?](#в-каких-случаях-следует-создавать-вспомогательные-блоки)
* [Зачем внешнюю геометрию и позиционирование задавать через родительский блок?](#зачем-внешнюю-геометрию-и-позиционирование-задавать-через-родительский-блок)

## JavaScript

* [Зачем нужен i-bem.js, если есть jQuery?](#зачем-нужен-i-bemjs-если-есть-jquery)

## У меня другой вопрос

Если вы не нашли ответ на свой вопрос, свяжитесь с нами [на форуме](https://ru.bem.info/forum/).

## В чем отличие БЭМ от OOCSS, AMCSS, SMACSS, SUITCSS?

1. БЭМ работает не только с [CSS](../method/bem-for-css/bem-for-css.ru.md), но и с [JavaScript](../method/bem-for-js/bem-for-js.ru.md).
2. БЭМ больше схож с [Web Components](https://www.webcomponents.org), чем с перечисленными решениями для CSS.
3. БЭМ предоставляет комплексное решение по созданию архитектуры проекта и помогает организовать процессы разработки.

   > Подробнее читайте в разделе [Применение методологии для решения задач веб-разработки](../method/solved-problems/solved-problems.ru.md).

## В чем разница между БЭМ и Web Components?

**Поддержка браузеров**

* Web Components [не поддерживается](http://caniuse.com/#search=Web%20Components) в Safari, iOS Safari, Internet Explorer, Firefox.
* БЭМ работает во всех браузерах.

**Инкапсуляция**

* В Web Components реализована через Shadow DOM.
* В БЭМ — с помощью [элементов](../method/key-concepts/key-concepts.ru.md#Элемент) блока.

**Работа шаблонов**

* В Web Components шаблоны всегда выполняются в браузере. Это может потребовать дополнительных решений проблем с индексацией.
* В БЭМ генерация шаблона возможна на этапе разработки. Это позволяет отдавать готовый HTML. Шаблоны могут выполняться как в браузере, так и на сервере.
* Web Components использует императивный принцип — интерполяцию строк.
* БЭМ использует декларативный подход, который позволяет гибко управлять шаблонизацией и избегать повторений.

**Вместо импорта HTML — сборка**

* Web Components использует [импорт HTML](https://w3c.github.io/webcomponents/spec/imports/), который работает непосредственно в браузере. Для объединения HTML-файлов используется инструмент [Vulcanize](http://webcomponents.org/articles/introduction-to-html-imports/#aggregating-network-requests).
* В БЭМ используется сборка. Для объединения файлов используются сборщики: [ENB](https://ru.bem.info/toolbox/enb/), [Gulp](http://gulpjs.com).

**Вместо Custom Elements — абстракция над DOM-деревом**

* В Web Components используются [Custom Elements](https://www.w3.org/TR/custom-elements/). Такой подход позволяет разместить на одном DOM-узле только один компонент.
* В БЭМ используется [БЭМ-дерево](../method/key-concepts/key-concepts.ru.md#БЭМ-дерево). Такой подход позволяет размещать на одном DOM-узле несколько компонентов ([БЭМ-сущностей](../method/key-concepts/key-concepts.ru.md#БЭМ-сущность)).

   > Подробнее читайте в разделе про [миксы](../method/key-concepts/key-concepts.ru.md#Микс).

## Полезен ли БЭМ в маленьких проектах?

Методология БЭМ предоставляет правила организации веб-проектов, независимо от их размера или количества разработчиков в команде. Даже если в вашей команде два человека и вы верстаете одностраничные сайты, БЭМ позволяет:

* Повторно использовать верстку
  * Небольшие однотипные проекты могут иметь похожую структуру. Например, посадочные страницы (landing) — разные снаружи, одинаковые внутри. Для их создания можно использовать готовые шаблоны.
  * В пределах одной страницы используются одинаковые [блоки](../method/key-concepts/key-concepts.ru.md#Блок): несколько кнопок, выпадающих списков или меню. Их можно взять из готовой библиотеки или реализовать свою библиотеку и использовать во всех проектах. 

* Быстро прототипировать верстку
  * Прототип сайта создается из блоков. Вместо верстки в БЭМ-проекте вы сразу проектируете интерфейс из готовых блоков. 

* Ускорить разработку
  * [Уровни переопределения](../method/key-concepts/key-concepts.ru.md#Уровень-переопределения) позволяют подключать библиотеки и доопределять блоки, не зависеть от обновлений библиотеки.
  * БЭМ-проект можно быстро начать с шаблонного проекта [project-stub](https://github.com/bem/project-stub) или [bem-express](https://github.com/bem/bem-express).

* Не зависеть от конкретного разработчика
  * Одинаковая структура всех проектов, одни правила организации кода, изолированные блоки облегчают передачу кода между разработчиками. 

* Ускорить рефакторинг
  * БЭМ-проект устроен таким образом, что изменения в одном блоке можно применить ко всем блокам в проекте. При этом нет необходимости знать все возможные случаи использования этого блока.
  * [Система именования](../method/naming-convention/naming-convention.ru.md) БЭМ-сущностей позволяет вложить смысл в имена и сделать их максимально информативными для разработчика, то есть писать самодокументируемый код.

* Ускорить и упростить смену дизайна за счет уровней переопределения. 
* Минифицировать CSS/JS даже в одностраничном проекте.

## В чем разница между БЭМ и Bootstrap?

[Bootstrap](http://getbootstrap.com/) — это свободный набор сверстанных блоков для создания сайтов и веб-приложений.

БЭМ — это методология, позволяющая:

* создавать архитектуру проекта;
* разрабатывать веб-приложения независимыми блоками;
* упрощать поддержку проектов.

Также существует ряд библиотек с открытым исходным кодом:

* [bem-components](https://ru.bem.info/platform/libs/bem-components/) — библиотека блоков, содержащая контролы форм и другие базовые компоненты веб-интерфейса;
* [bem-core](https://ru.bem.info/platform/libs/bem-core/) — библиотека блоков, предоставляющая специализированный [JavaScript-фреймворк](https://ru.bem.info/platform/i-bem/) для веб-разработки.
* [bem-history](https://ru.bem.info/platform/libs/bem-history/) — БЭМ-обертка над History API.

## Когда создавать блок, когда — элемент?

Методология БЭМ не устанавливает строгих правил создания блоков и элементов. Многое зависит от конкретных реализаций и личных предпочтений разработчика. Выбирайте то, что подходит именно вам, учитывая [рекомендации](../method/quick-start/quick-start.ru.md#Когда-создавать-блок-когда--элемент).

## Как изменить внешний вид блока?

Внешний вид блока можно изменить при помощи модификаторов или миксов.

### Используйте модификаторы

Если существует вероятность переиспользовать блок в данном оформлении.

### Используйте миксы

Если блок имеет специфичное оформление только для данного окружения и не будет переиспользован на проекте.

> Подробнее про применение миксов и модификаторов читайте в разделе [Когда создавать модификатор, когда — микс?](#Когда-создавать-модификатор-когда--микс).

## Зачем в именах модификаторов и элементов указывать имя блока?

Имя блока в именах модификаторов и элементов:

* Обеспечивает пространство имен.

   > Это позволяет ограничить влияние элементов и модификаторов одного блока на другой.
   >
   > **Пример**
   >
   > ```html
   > <!-- Модификаторы `button_size_m` и `select_size_m` не будут влиять друг на друга. -->
   > <div class="button button_size_m">...</div>
   > <div class="select select_size_m">...</div>
   > ```

* Позволяет использовать миксы.

   > При использовании миксов необходимо явно указывать пространство имен для модификаторов, чтобы было ясно к какой из сущностей на данном DOM-узле относится модификатор.
   >
   > **Пример**
   >
   > ```html
   > <!-- Имя модификатора `button_size_m` позволяет определить,
   > что модификатор относится к кнопке, а не к миксу — блоку `dropdown`. -->
   > <div class="button dropdown button_size_m">...</div>
   > ```

* Облегчает поиск в коде.

   > Уникальные имена облегчают поиск сущностей в коде и файловой структуре.

## Зачем создавать отдельные директории и файлы для каждого блока и технологии?

Для удобства разработки и поддержки проекта файловую структуру БЭМ-проекта разделяют на вложенные директории и файлы.

Вы можете придерживаться [рекомендуемой структуры проекта](../method/filestructure/filestructure.ru.md#nested) или использовать любую альтернативную:

* [Flat](../method/filestructure/filestructure.ru.md#flat)
* [Flex](../method/filestructure/filestructure.ru.md#flex)

## Наследуют ли элементы блока его CSS-свойства?

Да. Механизм наследования CSS-свойств в БЭМ ничем не отличается от привычного наследования.

Чтобы одинаково оформить все элементы блока, целесообразно задать CSS-правила непосредственно блоку.

Чтобы оформить элементы по-разному, CSS-правила определяют непосредственно для каждого элемента. Возникших при этом повторов в результирующем коде можно избежать с помощью CSS-оптимизатора.

## Почему не стоит создавать блоки-обертки?

Абстрактные обертки не имеют никакого смысла, так как задачи, которые они решают, реализуются с помощью миксов и дополнительных элементов блока.

> Подробнее читайте в разделе [HTML по БЭМ](../method/bem-for-html/bem-for-html.ru.md).

## Почему не стоит создавать элементы элементов (block\__elem1\__elem2)?

Наличие элементов элементов ограничивает возможность изменять внутреннюю структуру блока. Элементы нельзя поменять местами, удалить или добавить без корректировки существующего кода.

> Подробнее читайте в разделе [Быстрый старт](../method/quick-start/quick-start.ru.md#Принципы-работы-с-элементами).

## Когда создавать модификатор, когда — микс?

### Создавайте модификатор

Если нужная вам реализация может использоваться повторно и не зависит от реализации других компонентов страницы. Например, блок `select` имеет модификаторы: **hovered**, **pressed**, **disabled**, **focused**, **opened**.

![Модификаторы блока select](https://cdn.rawgit.com/bem-site/bem-method/bem-info-data/faq/faq_create_modifier.svg)

### Создавайте микс

Если нужная вам реализация требуется только для данного окружения и в данном виде точно не будет переиспользована на проекте.

Например, в большинстве случаев создается микс, если:

* реализуется определенная бизнес-логика проекта;
* задается [внешняя геометрия](../method/bem-for-css/bem-for-css.ru.md#Внешняя-геометрия-и-позиционирование) для данного окружения.

## Когда создавать булевый модификатор, когда — модификатор «ключ-значение»?

### Создавайте булевый модификатор

Если важно только наличие или отсутствие модификатора у блока, а его значение несущественно. Например, модификатор, описывающий состояние «отключен»: `disabled`.

**Пример**

```html
<div class="button button_disabled">...</div>
```

### Создавайте модификатор вида «ключ-значение»

Если состояний у блока может быть несколько. Например, для описания размеров блока можно использовать модификатор `size` с допустимыми значениями `s`, `m` и `l`.

**Пример**

```html
<div class="button button_size_s">...</div>
<div class="button button_size_m">...</div>
```

## Как выбрать имя модификатора?

Выбирайте имена модификаторов, опираясь на семантику, а не на описываемые им CSS-свойства.

**Пример**

```html
<!-- Неудачное имя модификатора -->
<button class="button button_background_yellow">...</button>
<!-- Удачное имя модификатора -->
<button class="button button_view_action">...</button>
```

Имя модификатора `button_background_yellow` неудачное, потому что:

* При изменении фона с желтого (`yellow`), например, на красный (`red`) придется менять не только CSS-код, но и название селектора, шаблоны и, вполне вероятно, JavaScript-код.
* При добавлении других CSS-свойств, например, `border`, `line-height`, имя модификатора перестанет соответствовать его содержанию.

## Как сделать глобальные модификаторы для блоков?

В БЭМ отсутствует понятие глобальных модификаторов, так как имя любого модификатора содержит имя блока или элемента.

Если требуется вынести CSS-свойство за пределы одного блока и применять его к разным БЭМ-сущностям в проекте, необходимо создавать отдельный блок, реализованный в технологии CSS. После чего совместить реализацию разных блоков с помощью [миксов](../method/key-concepts/key-concepts.ru.md#Микс).

> Подробнее читайте в разделе [Стилизация групп блоков](../method/bem-for-css/bem-for-css.ru.md#Стилизация-групп-блоков).

## Почему нельзя писать имя модификатора блока в имени элемента (block_mod__elem)?

Элемент — составная часть блока, а не модификатора блока. Таким образом, только имя блока может задавать пространство имен для элементов.

Это важно, потому что:

* Блок может иметь много модификаторов.

   > **Пример**
   >
   > ```html
   > <div class="button button_size_m button_theme_islands button_type_submit">
   >     <div class="button__text">...</div>
   > </div>
   > ```

* Модификатор определяет состояние блока/элемента, которое может быть изменено во время выполнения скрипта JavaScript.

## Как адаптировать сайт к различным устройствам?

Существует несколько способов изменять разметку страницы на основе ширины окна браузера:

* [используя Media Queries](#media-queries);
* [переключая модификаторы](#Переключение-модификатора).

В обоих случаях необходимо определить контрольные точки (breakpoints), условия, при которых раскладка сайта меняется с одной на другую.

### Media Queries

Файловая структура:

```files
common.blocks/
    button/
        button.css    # CSS-реализация кнопки
```

CSS-реализация:

```css
@media (max-width: 767px) {
    .button {
    	  left: 0;
    }
}

@media (max-width: 479px) {
    .button {
        right: 0;
    }
}
```

> **Примечание** Имена блоков должны быть достаточно общими, для того чтобы его можно было использовать более чем с одной целью. Не стоит называть блок `sidebar-left`, если при изменении ширины экрана, его позиция изменится на `right`.

### Переключение модификатора

Файловая структура:

```files
common.blocks/
    button/
        _position/
            button_position_left.css
            button_position_right.css
        button.js                         # JS-реализация кнопки
```

button_position_left.css:

```css
.button_position_left {
    left: 0;
}
```

button_position_right.css:

```css
.button_position_right {
    right: 0;
}
```

Изменение CSS-классов на DOM-узле происходит при помощи JavaScript.

> Подробнее читайте в разделе [Переключение модификаторов](https://ru.bem.info/platform/tutorials/i-bem/modifiers/#Переключение-toggle-модификатора).

## Можно ли совмещать теги и классы в селекторе?

Совмещение тега и класса в селекторе повышает специфичность CSS-правил. Методология БЭМ не рекомендует совмещать теги и классы в селекторе.

> Подробнее читайте в разделе [Совмещение тега и класса в селекторе](../method/bem-for-css/bem-for-css.ru.md#Совмещение-тега-и-класса-в-селекторе).

## Можно ли использовать вложенные селекторы?

Вложенные селекторы увеличивают связанность кода и делают его повторное использование невозможным. Методология БЭМ допускает использование таких селекторов, но рекомендует свести их к минимуму.

> Подробнее читайте в разделе [Вложенные селекторы](../method/bem-for-css/bem-for-css.ru.md#Вложенные-селекторы).

## Можно ли использовать комбинированные селекторы?

Комбинированные селекторы имеют более высокую специфичность CSS-правил, чем одиночные. Успешность переопределения таких селекторов сильно привязана к порядку их объявления. Методология БЭМ не рекомендует использовать комбинированные селекторы.

> Подробнее читайте в разделе [Комбинированные селекторы](../method/bem-for-css/bem-for-css.ru.md#Комбинированные-селекторы).

## Можно ли использовать селекторы по пользовательским тегам?

В HTML блоки могут выражаться с помощью пользовательских HTML-элементов ([Custom Elements](https://www.w3.org/TR/custom-elements/)) с целью:

* улучшить структуру веб-страницы и добавить смысловое значение заключенному в них содержимому;
* использовать селекторы по пользовательским тегам вместо селекторов по классам;
* связать с HTML-элементом дополнительные данные, с которыми потом будет работать JavaScript.

Методология БЭМ за улучшение семантики веб-страниц, но не рекомендует отказываться от селекторов по классам в пользу пользовательских тегов. В случае такой замены классы можно будет использовать только для модификаторов.

**Пример**

HTML-реализация:

```html
<icon-twitter class="icon_social_twitter">...</icon-twitter>
```

CSS-реализация:

```css
icon-twitter {}
.icon_social_twitter {}
```

В таком подходе существует ряд ограничений:

* невозможно использовать [миксы](../method/key-concepts/key-concepts.ru.md#Микс);
* не любой блок можно выразить пользовательским HTML-элементом. Например, для всех ссылок необходим тег `<a>`, а для полей — `<input>`.

## Почему не стоит делать общий сброс стилей (reset)?

На блоки не должны влиять CSS-правила, созданные для всей страницы. Это нарушает их независимость и затрудняет повторное использование.

Общий сброс стилей по сути реализуется с помощью [глобальных CSS-правил](#Как-сделать-глобальные-модификаторы-для-блоков), которые в большинстве случаев пишутся к селекторам на тег, что нежелательно делать в БЭМ-проекте.

## Почему не стоит писать block_mod вместо block block_mod?

Если оставить только класс модификатора без указания класса самого блока/элемента, то все базовые CSS-свойства блока/элемента необходимо будет определить в модификаторе.

Модификатор определяет состояние блока/элемента, которое может быть изменено во время выполнения скрипта JavaScript. Таким образом, копировать базовые CSS-свойства блока придется во все его модификаторы.

**Пример**

```html
<div class="button_size_m button_theme_islands button_type_submit">
    <div class="button__text">...</div>
</div>
```

> **Примечание.** Совмещение нескольких модификаторов на одном и том же DOM-узле приведет к дублированию кода, реализующего базовую функциональность (логику и стили) блока.

## В каких случаях следует создавать вспомогательные блоки?

Методология БЭМ не устанавливает строгих правил создания блоков-хелперов. Многое зависит от конкретных реализаций и личных предпочтений разработчика. Если такой блок необходим, то можно воспользоваться [миксом](../method/key-concepts/key-concepts.ru.md#Микс).

Примером вспомогательного блока в [bem-core](https://ru.bem.info/platform/libs/bem-core/) может служить блок `clearfix`, а в [bem-components](https://ru.bem.info/platform/libs/bem-components/) — `z-index-group`.

## Зачем внешнюю геометрию и позиционирование задавать через родительский блок?

Чтобы компонент оставался независимым, CSS-свойства, которые помешают его переиспользовать в другом окружении (например, `margin` и `position`), задают через родительский блок.

> Подробнее читайте в разделе [Внешняя геометрия и позиционирование](../method/bem-for-css/bem-for-css.ru.md#Внешняя-геометрия-и-позиционирование)

## Зачем нужен i-bem.js, если есть jQuery?

[i-bem.js](https://ru.bem.info/technology/i-bem/) не предназначен для замены фреймворка общего назначения, такого как jQuery.

`i-bem.js` позволяет:

* разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
* интегрировать JavaScript-код с шаблонами и CSS-правилами в стиле БЭМ;
* описывать логику работы блока как набор состояний.
